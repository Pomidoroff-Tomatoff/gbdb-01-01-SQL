MySQL (2022.04.08--22.05.04)

Литература по СУБД:
    Руководство по оформлению кода в SQL: 
        https://www.sqlstyle.guide/ru/
    «Изучаем SQL», Линн Бейли
    «Введение в системы баз данных», Крис Дж. Дейт
    «Изучаем SQL», Алан Бьюли
    «SQL. Сборник рецептов», Энтони Молинаро
    Учебник по SQL: 
        https://learndb.ru/ (другие курсы)

Преподавательский состав
    Преподаватель вебинаров: Кирилл Иванов
    Лекции (видео-запись): Игорь Симдянов
    Наставник: Михаил Чирков
    Наставник: 
    Наставник: 
    
Telegram (это BigDATA):
    https://t.me/+cIo3krhbes01NjAy

Готовая виртуальная машина с Ubuntu v16 и MySQL 5.7: 
    https://yadi.sk/d/bS5Wm135JQYRkQ 
    (пароль от учетки Linux -- student: master)
    (пароль от учётки MySQL -- root: master)
Процесс установки виртуальной машины:
    https://yadi.sk/i/EH0MDN12xVm-pQ

DBeaver
    https://dbeaver.io/download/ 
    Настройки:
        encoding:  Data Editor -> Binary Editor: Text file encoding: UTF-8
        ... ещё см. ниже более подбробно

Установка MySQL
    Учебные базы данных MySQL:
        dev.mysql.com/doc/index-other.html
        Или: mysql.com -> documentation -> More -> Exqample Databases
        -- проектирование типовых решений:
            * employees (инфо по использованию
            * sakila     на ссылке "view")

        Установка:
            mysql> SOURCE C:/TEMP/sakila-db/sakila-schema.sql;
            mysql> SOURCE C:/TEMP/sakila-db/sakila-data.sql;

    MySQL под Windows
        -- последняя версия, для Windows 10 или выще:
            https://dev.mysql.com/downloads/mysql/
        -- для версии Windows, ниже 10-ой MySQL-8 может отказаться работать.
            * window 7: MySQL 5.7
            * старые версии MySQL: https://downloads.mysql.com/archives/community/
        -- установка всего по умолчанию
        -- сервер установить как службу и запустить при автозагрузке...
        -- пользователь root:
            USR: root
            PW: 12345
        -- можно сделать ещё одного пользователя...
        -- документация:
            mysql.com -> documentation -> MySQL Server -> + -> выбор версии
            https://dev.mysql.com/doc/
    MySQL в Mac OS/X
        -- требуется XCode (интегрированная среда разработки), нужны  
            * инстрменты командной строки
            * компилятор
            * проверка установки XCode:
                xcode-select -p /Applications/Xcode.app/Contents/Developer
                если что-то ни так
    MySQL под Linux Ubuntu
        -- необходимо обновить индексы пакетного менеджера apt-get:
            sudo apt-get update
        -- далее обновляем систему:
            sudo apt-get upgrade
        -- установка MySQL:
            sudo apt-get install mysql-server
        -- проверка установленного и запущенного сервера:
            ps aux | grep mysqld
            * процесс называется "mysql", а запущен "/usr/sbin/mysqld"
                или
            service mysql status
            * интересно, что служба называется "mysql.service"
        -- после установки необходима выполнить настройку:
            sudo mysql_secure_installation
            ...
    MySQL под Linux Ubuntu: запуск нескольких серверов одновременно
        -- утилита mysqld_multi и её особенности
        -- обычный запуск сервера как службы надо отключить

Настройка 
    Конфигурациия:
        https://dev.mysql.com/doc/refman/8.0/en/option-files.html
        -- файлы конфигурации и их расположение
        -- формат конф. файла, параметры и их значения

    Редактор настройки:
        mysql_config_editor
        https://dev.mysql.com/doc/refman/8.0/en/mysql-config-editor.html

Запуск MySQL:
    Windows, команда:
        mysql -u USER -p PASS  -- кажеться так
        * если (наверное) в домашнем каталоге пользователя 
          лежит файл my.cnf, то
    Конфиг, (https://dev.mysql.com/doc/refman/8.0/en/option-files.html)
    Windows: конфиг-файл с настройками пользователя(ей) по умолчанию:
        my.cnf -- в домашнем каталоге с явками и паролями, формат:
            [mysql] -- пока неизвестно, что за раздел, но какой-то важный
            user = root
            password = 12345

            [client] -- видимо, клиентская программа
            user = root
            password = 12345
    Linux, команда:
        mysql
    Linux, конфиг-файл в домашнем каталоге (~)
        .my.cnf -- начинается с точки, расположен в домашнем каталоге

IDE
    Workbench 
    -- входит в поставку MySQL (Oracl)
    -- только MySQL серверы
    -- нативный (родной, местный) инструмент
        * можно управлять сервером как сервисом (запускать, останавливать)...
    -- ER Diagrams (ERR Diagram):
        Database -> Reverse Engineer (или crtl + R) -> ...указать базу из списка... -> ER диаграмма
    -- Safe Updates (rejects UPDATEs and DELETEs with no restrictions)
        * отменить обновление и разрешить удаление без ограничений
          !> снять эту галочку и пере-подключиться!
          !> Workbench Preferences -> SQL Editor: группа "Other", элемент "Safe Updates" = OFF (снять галочку)


    DBeaver 
        https://progtips.ru/bazy-dannyx/menedzher-baz-dannyh-dbeaver.html#i
    -- сайт: dbeaver.io
    -- поддерживает серверы: MySQL, PostegSQL,...
    -- бесплатный (Community Edition)
    -- горячие клавиши:
        Ctl + shift + L -- подсказа по клавишам!
        Ctrl + Space -- подсказки;
        Alt + X -- исплнить всё или выделенное;
        Ctrl + Enter -- исполнить выражение па строке с курсором;
        Ctrl + PgUp / Ctrl + PgDn -- навигация между вкладками.
        Ctrl + / -- переключение комментарий--код (однострочный)
        Ctrl+ Shift + / -- блочный комментарий
    -- ошибки:
        * Connect to (имя сервера): Public Key Retrieval is not allowed
          ** сервер MySQL не запущен: можно... воспользоваться Workbench, чтобы запустить его оттуда или запустить службу руками...
    -- кодировка: 
            General -> Workspace: (в панели параметров справа) Text file encoding = Other = UTF8
        или (тоже самое, но через поиск Preference)
            encoding:   Data Editor -> Binary Editor: 
                        Text file encoding = Other = UTF8 (переключить с умолчания на специально выбранное)
        или
            добавить ключ запуск в коммандную строку:
                -vmargs -Dfile.encoding=UTF8
    -- Стиль кода:
        https://question-it.com/questions/647923/kak-pomenjat-zaglavnye-bukvy-v-dbeaver
        > Место: Windows -> Preferences -> Editors -> SQL Editor -SQL Formatiing (форматирование):
            >> Регистр ключевых слов: Upper (и всё)
            >> Форматирование: "Стандартный"
        > complition (в строке поиска Preferences):
            >> SQL Editor -> Code Completion:
                * Insert case = Default
                * Replace current word = "turn-off", выкл.
        > formationg (в строке поиска Preferences):
            >> SQL Editor -> Formatting:
                * Keyword case: = Upper
            >> Formatter: Default formatter

    -- Список подключений, окно-докер слева: 
        * Window (Окна) -> DataBases (базы данных)
        * Создаём подключение (MySQL 8+ - 127.0.0.1): 
            > нажать вилку с "+" и выбрать MySQL в этом окне
              или на инструментальной панели или в меню 
            > Меню: База данных -> Новое соединение: 
                >> выбрать MySQL 
                >> хост...
                >> пользователя: root
                    и его пароль
    -- Перед началом работы с кодом (скриптом) нужно каждый раз выбирать подключение:
        * Текущее подключение (на инстументальной панели)
            > MySQL 8+ - 127.0.0.1
                >> если этого подключения нет, то создать его (см. выше)
            > Текущую базу данных (каталог, схему)
    -- Стиль оформления кода (принятого в среде программистов ):
        * https://www.sqlstyle.guide/ru/

    -- ER Diagrams <- View Database (разные свойства, в том числе и диаграмма)
        https://dbeaver.com/docs/wiki/ER-Diagrams/
        Window -> Show view -> Database Navigator (палитра слева со списком объектов, в том числе и баз) слева -> 
        -> Databases (список баз данных) -> 
        -> выбрать в списке базу и вызвать меню объекта (правая кнопка) ->
        -> в меню объекта пукт "View Database" (или F4)
        в правом окне получем строку со вкладками "Properties" и "ER Diagram".
    
    -- Update ERROR:
        не даёт обновлять записи, пока что-то не разрешишь это в 2-х разеных окошках...        

    DbForge (аналог DBeaver)
        https://www.devart.com/dbforge/mysql/studio/
        -- есть бесплатный
    phpMyAdmin
    -- среда для работы с серверами Apach...
    JetBrains DataGrip
    JetBrains pyCharm


Введение
    DDL -- Data Definition Language -- язык описания данных.
        * создание объектов: табличек, 
    DML -- Data Manipulation Language -- язык манипуляции данных.
        * СRUD-операции (Create, Read, Update, Delete)

Нормальные формы
    1 НФ: атомарный вид (то есть, максимально простой).
    2 НФ: отсутствие дублирований данных (используются ключевое поле для ссылки на данные).
    3 НФ: для каждой сущности реального мира своя справочная таблица.
    3+НФ: у таблицы может быть только один первичный ключ.
    4 НФ: ... (здесь не изучается)
    5 НФ: ...
    6 НФ: ...


СТРУКТУРА КУРСА:
Вебинар: интерактиное занятие с преподавателем.
Лекция (видео-урок) можно посмотреть сразу, как он станет доступен -- обычно в тот же день, что и...
ДЗ: надо сдать в течении 7 дней, но можно отложить ещё на неделю. Для этого нужно указать "сдам позже" (преподаватель ставит "не сдано" и ждёт, когда ученик сделает и сдаст ДЗ)
     1. ВЕБИНАР Установка и знакомство
     2.  лекция DDL: Управление БД. Язык запросов SQL.
     3. ВЕБИНАР DDL: Введение в проектирование БД.
                     DDL + CREATE, ALTER, DROP
     4. ВЕБИНАР DML: CRUD-операции (создание, чтение, обновление, удаление).
     5.  лекция SELECT: Операторы, фильтрация, сортировка и ограничение. Агрегация данных.
     6. ВЕБИНАР SELECT: --//--
     7.  лекция SELECT, JOIN: Сложные запросы
     8. ВЕБИНАР SELECT, JOIN: Сложные запросы
    >>> продвинутый материал
     9.  лекция Транзакции, переменные, представления.
                Администрирование.
                Хранимые процедуры и функции.
                Тригеры.
    10. ВЕБИНАР --//--
    11.  лекция Оптимизация запросов.
                NoSQL.
    12. ВЕБИНАР Оптимизация запросов.

    00. !!! КУРСОВАЯ РАБОТА !!!

БАЗЫ ДАННЫХ
    Типы
        -- Иерархические СУБД (самое простое, что приходит в голову)
            * деревью были хорошо изучены и готов мат-аппарат
            * невозможность организовать отношения многого ко многим
        -- Сетевые (графовые): ценность приобретают связи бежду узлами
            * сложность изменений
        -- Реляционные (Эдгар Кодд, 1970 г)
            * первая РСУБД Oracle -- 1979 год
    Производители:
        Коммерческие: Oracle, MS SQL, IBM DB2
        Некоммерческие: MySQL, PostgreSQL, Firebird
        Самые популярные: MS SQL и PostgreSQL.
    Индекс популярности использования БД:
        https://db-engines.com/en/ranking
    Развитие сети интернет (множестов пользователей и данных):
        -- распределённые БД: данные перестали умещаться на одном сервере
            * сложность реализации стандартного SQL
            * появление специализированных NoSQL:
                Redis, MongoDB, ElasticSearch, ClickHouse, Cassandra
            * шардирование: разделение данных на части, если они не влезают в ОЗУ на одном сервере
            * проблема: разрыв связи

    ОСНОВЫ РЕЛЯЦИОННЫХ БАЗ ДАННЫХ
        Таблица:
            -- должна содержать минимум один столбец
            -- может не содержать строк вообще (данных), тогда есть только шапка (описание структуры)
            -- строки не упорядочены, поэтому нельзя выбрать первую или последнюю строки...
            -- primary key: каждая строка однозначно определяется первичным ключом
                * ключ уникален
                * все строки разные (следствие уникальности ключа)
                * это относительная таблица -- по ней можно строит отношения (relation)
                * по ключу можно строить отношение -- relation
            -- внешний ключ: ключевое поле, связанное с primary key другой таблицы
                * позволяет извлекать связанные данные
        Транзакция
            -- объединение нескольких операции чтения и записи в одну логическую единицу
            -- выполняется либо вся полностью с фиксацией изменений,
               либо прерывается и откат к исходному состоянию
            -- значительно упрощает обработку ошибок
            -- ACID -- гарантии безопасности транзакции
                * Atomicy -- атомарность, неразрывность всех операций транзакции
                    > определяет рекацию СУБД на сбой;
                    > если транзакцию не удалось завершить, то транзакция прерывается и 
                      СУБД выполняет откат назад все уже выполненные операции записи,
                      в исходное до начала транзации состояние;
                    > без атомарности не было понятно, какие операции выполнены, а какие нет;
                    > исключает дублирование при попытке выполнения транзакции повторно;
                * Consistency -- согласованность и целостность, сохранение бизнес-правил состояния данных
                    > выполнение бизнес-правил как до начла транзации, так и после завершения транзакции,
                      например, если до начала не было отрицательного возраста человека, 
                      то и после завершения это бизнес-правило должно выполняться.
                    > данные переходят из одного корректного состояния в другое, так же корректное;
                    > техничское состояние данных (целостность внещнего ключа (ссылка не должна потеряться), 
                      ограничение уникальности)
                * Isolation -- изолированность
                    > паралельно выполняемые транзакции не видятж друг-друга и не могут помешать друг-другу;
                    > транзакция выполняется так, как будт-то она одна единственная в БД.
                * Durability -- сохраняемость, 
                    > надёжное место для сохранения данных;
                    > даже в случае сбоя данные сохраняются.
            -- Обеспечивает блокировку необходимых для транзакции данных до конца выполнения
                * данные могут быть недоступны до окончания транзакции;
                * при высоких нагрузках это может оказаться неприемлимым;
                * в случае больших данных, размещённых на нескольких серверах, -- это превращается в проблему
        Распределённые системы 
            -- CAP-теорема: программа может быть Хорошей, Быстрой и Дешёвой -- выбирайте любые 2-а св-ва!
                * Consistency -- согласованность 
                    > все клиенты должны прочитать одно и то же значение в ответ на один и тот же запрос,
                      даже если в это время производиться обновление данных;
                * Availibility -- доступность
                    > все клиенты всегда имеют возможность Читать и Записывать данные
                    > мы не можем ждать для этого завершения каких-либо операций
                * Partition tolerance -- устойчивость к разделению
                    > можно разделить между несколькими машинами;
                    > работает даже в случае отказа одного из сегментов.
            -- Состояния БД: ни одна работающая база данных не может находиться сразу в трёх состоянихя
                * C--A (согласованность и доступность), как правило один компьютер:
                    > MySQL, PostgreSQL
                * A--P (доступность и устойчивость к разделению):
                    > Cassandra, Riak
                * C--P (согласованность и распределённость): 
                    > Redis, MongoDB
                    > долго ждём операций обновления БД
            -- Современная структура: 
                * SQL-БД обеспечиваю основное хранение данных
                * NoSQL -- обеспечивают 
                    > специальные задачи
                    > сетевую связанность в распределённых нестабильных средах

    MySQL и КЛИЕНТЫ
        Особенности взаимодействия MySQL и клиентами
        
        mysql -u user_name -h 192.168.0.12 -P 3306 -p
            -u user_name -- пользователь
            -h IP -- хост
            -P number -- порт (напр. 3306)
            -p -- пароль
        
        Узнать порт, который назначен серверу (службе) mysql:
            * как команду mysql> SHOW VARIABLES LIKE 'port'
            * как команду Bash (под root): netstat -tlnp
        
        mysql-клиент, команды:
            \G -- вертикальный вывод: (после запроса) вывод не по строкам, а по столбцам
            \s, STATUS  -- статус сервера
                > версия
                > пользователь
                > порт
                > кодировки
            \!, SYSETEM -- выполнить системную команду, напрмер:
                    mysql> SYSTEM dir   -- это под Windows
                    mysql> SYSTEM ls ~  -- это под Linux
            \q, EXIT  -- выход
            \., SOURCE, маршрут-имяфайла.sql -- запуск файл SQL (без кавычек, даже если в полном имене есть пробелы)
        
        Параметры запуска клиента
            -- могут быть записаны в конфигурационный файл:
                >  my.cnf -- для Windows (в начале нет точки!)
                > .my.cnf -- для Linux (точка для скрытого файла в Unix объязательна)
            -- структура кон. файла:
                [mysql] -- раздел с именем клиента (сдесь "мysql"), кот. адресованы параметры
                user = user_name
                password = пароль
                [client] -- все клиенты дистрибутива MySQL, в том числе раздел и для утилиты mysqldump
                user = user_name
                password = пароль
                <EOF>
                * для ограничения доступа к этому файлу:
                    chmod 0600 ~/.my.cnf
        SQL-дамп БД
            mysqldump db_name > db_dump_filename.sql
                -- дамп базы данных db_name 
                -- запускается в терминале ОС, а не в клиенте mysql

            mysql db_name < db_dump_filename.sql
                -- развёртывание дампа в базу данных на сервере MySQL с использованием утилиты mysql
            mysql  SOURCE db_dump_filename.sql
            mysql> SOURCE db_dump_filename.sql
                -- так же развёртывание дампа, можно уже в самом интерпретаторе

            mysql db_name
                -- запуск клиента с выбором БД по умолчанию

        Архитектура MySQL:
            -- (запросы <->) ЯДРО <-> ДВИЖОК (InnoDB, MyISAM, Memory, Archive)

        Системная база данных: mysql
            -- только MySQL
            -- набор представлений, для унификации запросов:
                * information_schema -- информационная схема
                    > виртуальная, расположена тольков ОЗУ (нет физ-представления на HDD)
                        >> невозможно выбрать командой "USE"
                    > изменение таблиц этого представления недопускается...
                    > такую базу должны поддерживать все СУБД, поддерживающие стандарт SQL;
                    > SELECT * FROM information_schema.SCHEMATA
                        >> таблица "SCHEMATA" содержит списо баз данных...
                    > SELECT * FROM information_schema.TABLES WHERE table_schema = 'shop'\G

    ДОКУМЕНТАЦИЯ
        HELP, \h  -- помощь, команда клиента (";" не нужны)
            Прим: HELP DESCRIBE
        Сайт документации MySQL:
            mysql.com -> documentation -> MySQL Server -> + -> выбор версии
            https://dev.mysql.com/doc/
        


    УПРАВЛЕНИЕ БД
        -- каждая БД расположена в своём каталоге 
            * если каталог удалить, то база пропадёт из общего списка
            * если ОС чувствительна к регистру символов в имени каталога, 
              то имена в разных регистрах будут означать разные БД...
        -- текущее расположение всех баз:
            SHOW VARIABLES LIKE 'datadir'
            (C:\ProgramData\MySQL\MySQL Server 8.0\Data\)
        -- запрос или команда:
            * запрос передаётся на сервер только после обнаружения символа ";"
            * всегда завершается ";"
            * для длинных команд можно перейти на следующую строку вводом "Enter"

        CREATE DATABASE db_name;
            -- создание пустой базы данных
            -- если такая база уже есть, то приводит к ошибке
        CREATE DATABASE IF NOT EXISTS db_name;
            -- создание с условием
            -- не приводит к ошибке
        DROP DATABASE db_name;
            -- удаление базы db_name
            -- приводит к ошибе, если базы нет
        DROP DATABASE IF EXISTS db_name;
            -- удаление без ошибок
        USE db_name
        \u db_name
            -- выбор БД по умолчанию
            -- не является SQL-оператором, а командой клиента mysql, поэтому ";" можно не указывать
            !! неСтандартная команда, только MySQL
        SHOW TABLES;
            -- вывести список таблиц (если база данных выбрана)
            !- неСтандартная 
        SHOW TABLES FROM db_name;
            -- вывести список таблиц из БД "db_name"
        SELECT VERSION();
            -- вывести версию SQL-сервера
        SELECT mysql.User.User, mysql.User.Host,  FROM mysql.User;
            -- вывести поля User и Host таблицы User из (FROM) базы данных "mysql" и её таблицы "User";
            -- указаны полные, т. е. квалифицированные имена
        SELECT User FROM mysql.User;
            -- тоже, что и выше, но короче...
        SELECT User, Host FROM mysql.User;
            -- вывести поля User и Host из таблицы User базы mysql
        CREATE TABLE t_name (
            описание полей
            ...
        );
            -- создание таблицы "t_name" со списком полей
            -- возможна ошибка, если таблица существует
        CREATE TABLE IF NOT EXIST t_name (k INT);
            -- создание таблицы без ошибки
        DESCRIBE table_name ['fild_name'];  
            -- показать структуру таблицы
                * 'fild_name' -- только это поле
            -- каждая строка описывает одно поле в этой структуре
            -- LIKE-шаблоны:
                DESCRIBE table_name 'шаблон';
                    % -- заменяет любое количество символов
                    _ -- заменяет только 1-ин симовл
            !- нестандартный оператор (только MySQL).


ЯЗЫК ЗАПРОСОВ SQL
    Стандарт
        -- зародился в IBM и носил название SEQUEL (Structured English Query Language), но торговая марка была занята и название пришлось заменить на SQL 
        -- декларативный: описывает цель, а не инструкции
        -- в основе теория множества
        -- кросплатформенность
        -- наличие стандартов (1986, 1989, 1992, 1999, 2003, 2006 годах)
        -- Недостатки
            * слабоструктурированный
            * Старый (машинно ориентированный язык, а не человеко-ориентированный)
            * плохо взаимодействует с ООП-языками
                > стали появлятся ОРМ-системы, которые предоставляют объектно-ориентированный интерфейс к SQL
            * не универсальный -- нельзя создать программу в бинарном коде
            * множество диалектов (несмотря на наличие стандартов, идя впереди них)
        -- Компонетны:
            * комментарии
            * инструкции: DDL (описание) и DML (управление)
        -- Структура запроса
            SELECT id, name FROM users WHERE name='Иван'
            > выбрать (SELECT) поля id...
            > из (FROM) таблицы "users"
            > где (WHERE) значение поля "name" равно скаларному выражению "Иван"
        -- Экранирующие символы в запросах:
            SELECT 'Rubyst's world'; -- неправильно
            SELECT 'Rubyst\'s world'; -- правильно
            SELECT "Rubyst's world"; -- правильно, но двойные кавыки в PostgreSQL имеют специальное назначение
        -- Имена полей: любые символы, кроме "." и "\", "/" и ключевых слов
            * если имя содержит ключевое слове (INT, например), то его нужно взять в обратные ковычки:
                CREATE TABLE tbl (`create` INT); -- нет ошибки!

    Типы данных
        -- в поле определённого типа могут быть внесены только данные соотвествующего типа
        -- Типы данных:
            * Числовые
                > BIT -- bit value type
                  >> BIT(M), где M -- количество бит [от 1 до 64], по умолчанию -- 1.
                  >> BIT(1) может принимать значения 0 (FALSE), 1 (TRUE), NULL (и всё)
                  >> используется как логическое
                > целочисленные (https://dev.mysql.com/doc/refman/8.0/en/integer-types.html)
                  >> TINYINT   -- 1 байт:  0--256 
                  >> SMALLINT  -- 2 байта: 0--32767--65535
                  >> MEDIUMINT -- 3 байта: 0--8388607--16777215
                  >> INT       -- 4 байта: 0--2147483647--4294967295
                  >> BIGINT    -- 8 байта: 0--(2E+63 - 1)--(2E+64 - 1) // (2E+64 - 1 = 18446744073709551615)
                    Прим.: CREATE TABLE tbl (id INT(8) ZEROFILL) -- цифра 8 -- это формат отображения (но не задание байтов на число), т.е. 8-мь симовлов и пустые слева заполнить нулями
                > BOOL, BOOLEAN -- псевдонимы для TINYINT(1) с размером в 1 байт.
                  >> можно использовать как логическое, но размер большой...
                > вещественные (FLOAT (4 байта), DOUBLE (8 байт))
                > точные (DECIMAL) -- фактически строка, в которй записано число
                  >> самая медленная обработка
                  >> используется, чтобы избежать накопления ошибки при операции с вещественными цислами
                  >> финансовая сфера
                  >> Например DECIMAL(7,4) -- под всё число отводится 7 байт, а под друбную 4 байта
            * Строковые (фикрированные и переменного размера)
                > CHAR -- фиксированные
                > VARCHAR -- переменные с указанием максимального количества символов
                    >> для хранения используется специальная область в 65536 байт 
                    !> для всех таких полей в таблице этот объём переходить нельзя!!!
                > ТЕХТ (ИЛИ BLOB) -- объёмные бинарные данные или большие текстовые
                  >> TINYTEXT (256 байт)
                  >> TEXT (65536 байт)
                  >> MEDIUMTEXT (16Мб)
                  >> LONGTEXT (4 Гб)
                  >> хранятся в отдельной области памяти, чтобы не нарушать фиксированную длину записи
            * NULL (или NOT NULL) отсутствие данных (или присутсвие объязательно)
                > отсутствие данных
                > задаёт ограничение на столбец: разрешает или запрещает присваивать пустые значения
            * Календарные типы:
                > TIME -- время в течении суток (3 байта);
                > YEAR -- год (1 байт);
                > DATE -- дата с точностью до дня (3 байта);
                > DATETIME -- дата и время (8 байт);
                > TIMESTAMP -- то же, что и DATETIME, но:
                    >> размер поля в 4 байта, т. е. занимает в 2-а раза меньше места, чем DATETIME.
                    >> даты в диапазоне 1970--2038;
                Пример:
                    SELECT '2022-04-15 18:45:05'
                Примеры сложения и вычитания:
                    SELECT '2022-04-15 18:45:05' - INTERVAL 1 DAY;
                    SELECT '2022-04-15 18:45:05' + INTERVAL 1 WEEK;
                    SELECT '2022-04-15 18:45:05' + INTERVAL 1 YEAR;
                    SELECT '2022-04-15 18:45:05' + INTERVAL '1-1' YEAR_MONTH; -- кавычки объязательно!!!
                    SELECT '2022-04-15 18:45:05' + INTERVAL '1+1' YEAR_MONTH + INTERVAL 5 DAY;

            * Коллекции (множества или JSON-документы) или коллекционные типы:
                > ENUM -- елемент множества 
                    >> поле может принимать только одно значение из списка возможных значений;
                    >> список значений типа "строка" (через запятую): 'first','second','third'
                    >> внутреннее представление -- цифровое
                    Пример: first
                > SET -- несколько элементов множества (или весь список)
                    >> поле принимает набор значений из возможного списка;
                    Пример: first,second
                > JSON -- готовый объект языка JavaScript
                    Пример:
                        ALTER TABLE tbl ADD collection_json JSON;
                        DESCRIBE tbl;
                        INSERT INTO tbl VALUE (1, '{"first": "Hellow", "second": "TelePusik"}');
                        SELECT * FRON tbl;
                        SELECT collection_json->>"$.first" FROM tbl;
                        SELECT collection_json->>"$.second" FROM tbl;
                        +------------------------------+
                        | collection_json->>"$.second" |
                        +------------------------------+
                        | NULL                         |
                        | TelePusik                    |
                        +------------------------------+
                        2 rows in set (0.00 sec)
        -- Атрибуты:
            * NULL или NOT NULL
                > задаёт ограничение на столбец: 
                  разрешает или запрещает присваивать пустые значения
            * DEFAULT 
                > значение по умолчанию, если при создании записи значение полю не было присвоено
            * UNSIGNED
                > только для цифровых
                > только положительные (2 в 32 степени = 4'294'967'295)
                > положительные и отрицательные (2 в 31 степени = 2'147'683'647)

DDL (Data Definition Language)
    Таблица
        Обычная
            CREATE TABLE table_name (
                id BIGINT UNSIGNED NOT NULL,
                first_name VARCHAR(255),
                birthday DATE
            );
            CREATE TABLE table_name (
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
            );
        Временная (https://dev.mysql.com/doc/refman/8.0/en/create-temporary-table.html)
            CREATE TEMPORARY TABLE t_tmp LIKE user;
            -- создать временную таблицу t_tmp по структуре как user
               без внесения данных
            -- существует только в пределах текущего сеанса и автоматически удаляется при завершении сеанса
            -- одновременно в разных сеансах можно создать временную таблицу с одним и тем же именем безконфликтно!
            -- удаление базы данных не приводит к удалению временной таблицы.
            -- ВНИМАНИЕ! Не будет поддерживаться в дальнейшем, начиная с MySQL 8.0.13

        Вычисляемое поле -- "AS"
            CREATE TABLE table_name (
                x INT,
                y INT,
                summ AS (x + y) 
            );
            -- чтобы вычисляемое поле хранилось в таблице 
               необходимо добавить ключевое слово STORED:
                summ AS (x + y) STORED

        Вычисляемое поле с датой
            CREATE TABLE table_name (
                id BIGINT UNSIGNED NOT NULL,
                first_name VARCHAR(255),
                birthday DATE,
                age AS TIMESTAMPDIFF(YEAR, birthday, CURRENT_DATE())
            );
        Проверка (ограничение), CHECK:
            CREATE TABLE table_name (
                x INT,
                y INT,
                summ AS (x + y) CHECK (summ > 1)
            );
        -- или отдельно с собственным именем ограничения
            CREATE TABLE table_name (
                x INT,
                y INT,
                summ AS (x + y),
                CONSTRAINT summ_check_1 CHECK (summ > 1)
            );

    Индексы
        -- их использование ускоряет выполнение запросов
            > используются для ОПТИМИЗАЦИИ базы
        -- Имеют собственные имена (чтобы их можно было удобно различать)
        -- Типы:
            > BTREE -- бинарное дерево; ?????????????? НЕ ПОНИМАЮ ЭТОГО
                >> значения храняться по порядку
                >> все листовые страницы дерева храняться на одинаковом расстоянии от корня, что повышает скорость
                >> полезен для поиска по диапазону
                Пример:
                    CREATE INDEX index_of_catalog_id USING BTREE ON products(catalog_id);
            > HASH -- хэш-таблица.
                >> строится на основе хзш-таблицы
                >> полезен только для точного поиска с указанием всех столбцов индекса...
                Пример:
                    CREATE INDEX index_of_catalog_id USING BTREE ON products(catalog_id);
        -- Виды
            > обычный (не уникальный)
                >> при обращении может выдать больше одного значения (высокая селективность)
                INDEX или KEY
                Пример:
                    CREATE TABLE products (
                        id INT UNSIGNED PRIMARY KEY,
                        catalog_id INT UNSIGNED,
                        name VARCHAR(255) COMMENT 'Название',
                        KEY index_of_catalog_id(catalog_id)
                    );
            > уникальный (UNIQUE)
                >> селективность = 1;
                >> значения в них не должны повторяться;
                >> может быть несколько.
                Прим.
                    CREATE TABLE catalogs (
                        id SERIAL PRIMARY KEY,
                        name VARCHAR(255),
                        UNIQUE unique_name(name(10))
                    );
            > уникальный первичный ключ (PRIMARY KEY)
                >> уникальный индекс
                >> предназначен только для первичного ключа
                >> может быть только один
                Пример:
                    CREATE TABLE catalogs (
                        id INT UNSIGNED NOT NULL UNIQUE AUTO_INCREMENT PRIMARY KEY,
                        name VARCHAR(255) COMMENT 'Название'
                    ) COMMENT = 'Разделы каталога';
                или
                    CREATE TABLE catalogs (
                        id INT UNSIGNED NOT NULL UNIQUE AUTO_INCREMENT,
                        name VARCHAR(255),
                        PRIMARY KEY (id)
                    );
                или
                    CREATE TABLE catalogs (
                        id INT UNSIGNED NOT NULL UNIQUE AUTO_INCREMENT,
                        name VARCHAR(255),
                        PRIMARY KEY (id, name(10))  /* индекс сразу по 2-м столбцам и, при этом, */
                    );                              /* для name только первые 10 символов */
                или
                    SERIAL = BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE
                    -- это стандартная предпочтительная форма
                    CREATE TABLE catalogs (
                        id SERIAL PRIMARY KEY,
                        name VARCHAR(255)
                    )
                UNIQUE -- создаёт отдельный индекс
                PRIMARY KEY -- создаёт отдельный индекс
                >> случше их вместе не сочетать, а то получиться сразу два индекса
            > полнотекстовый
                >> для столбоцов типа TEXT
                >> позволяет производить полнотекстовый поиск
                >> здесь не рассматривается, так как на практике эта задача
                   решается специальными СУБД (ElasticSearch,...)

        -- Операции с индексами
            > Добавление индекса.
                >> Может быть создан (добавлен) в уже существующей таблице (products)
                Пример:
                    CREATE INDEX index_of_catalog_id ON products (catalog_id);
            > Удаление
                Прим.:
                    DROP INDEX index_of_catalog_id ON products;

    СВЯЗИ: Внешние ключи
        1--1 один к одному (разделённая таблица)
            -- примером может служить таблицы users и user_preferenses, 
               где каждой записи одной соответствует строго одна запись в другой таблицы
            -- такие таблицы можно объединить в одну
            Пример: связь 1--1
                CREATE TABLE users ( 
                    id SEREAL PRIMARY KEY,
                    name VARCHAR(255)
                );
                CREATE TABLE profiles (
                    user_id BIGINT UNSIGNED NOT NULL,
                    birthday DATE,
                    CONSTRAINT fk_profiles_user_id FOREIGN KEY (user_id) REFERENCES user.id
                ); /*-- или без именования связи: FOREIGN KEY (user_id) REFERENCES user.id */
            Пример: связь 1--1
                ALTER TABLE profiles ADD CONSTRAINT fk_profiles_user_id FOREIGN KEY (user_id) REFERENCES users(id);
                -- добавление внешнего ключа отдельно от описания таблицы (имя объязательно)
                ALTER TABLE profiles DROP CONSTRAINT fk_profiles_user_id;
                -- удаление внешнего ключа из описанной таблицы по имени внешнего ограничения
        1--X (один ко многим)
            -- таблица объектов (справочкик) + 
               + связанная таблица использоания объектов, ссылающаяся на справочник
        X--X (многие ко многим)
            -- два справочника (виды_объектов + склады) + 
               + таблица связи (каждый вид объекта может одновременно 
                 находиться на нескольких складах)

DML (Data Manipulation Language)

    CRUD-операции с данными (Create=INSERT + Read=SELECT + Update + Delete)
        -- Базовые операции
            > INSERT
                EN: https://dev.mysql.com/doc/refman/8.0/en/insert.html
                RU: http://www.mysql.ru/docs/man/INSERT.html)
                >> добавление данных в существующую таблицу;
                Пример:
                    INSERT INTO catalogs VALUES (NULL, 'Процессоры');
                    INSERT INTO catalogs VALUES (0, 'Системные платы');
                или
                    INSERT INTO catalogs VALUES
                        (DEFAULT, 'Процессоры'),
                        (DEFAULT, 'Системные платы');
                Примечание: 
                    NULL, 0, DEFAULT -- одно и то же для поля с инкрементом
                Пример: 
                    вставка без генерации ошибки при дублировании в уникальном поле
                    (просто не выполниться эта вставка)
                    INSERT IGNORE INTO catalogs VALUES (NULL, 'Процессоры');
                Пример:
                    в случае ошибки в уникальном поле будет выполнена операция UPDATE 
                    INSERT INTO ...
                Пример:
                    вставка только в указанные поля
                    INSERT INTO table_name (field_2, note) VALUE ('Процессоры', 'описание');

            > SELECT
                EN: https://dev.mysql.com/doc/refman/8.0/en/select.html
                RU: http://www.mysql.ru/docs/man/SELECT.html
                    http://www.mysql.ru/docs/man/Selecting_rows.html
                >> извлечение столбцов
                Прим.:
                    SELECT name, id FROM catalogs;
                или все столбцы без их указания
                    SELECT * FROM catalogs;
                и сортировка
                    SELECT * FROM users ORDER BY lastname;
                в обратном порядке
                    SELECT * FROM users ORDER BY lastname DESC;
                без повторений 
                    SELECT DISTINCT lastname FROM users ORDER BY lastname;
            > VALUES 
                en: https://dev.mysql.com/doc/refman/8.0/en/values.html
                -- конструктор таблицых значений
                -- конструкция, кот. возвращает набор из одной или нескольких срок в виде таблицы
                VALUE ROW(v1-1, v1-2), ROW(v2-1, v2-2);
                Пример: 
                    VALUES ROW(1), ROW(2);
                    -> column_0
                    -> 1
                    -> 2
                    -- возвращено две строки 1-ого столбца с именем column_0
            > VALUES и SELECT
                SELECT name_1, name_2 FROM (VALUES ROW(v1-1, v1-2), ROW(v2-1, v2-2) X(name_1, name_2));
                -- возвращаемые конструктором таблицных значений данные можно именовать и использовать в SELECT
                -- сдесь 'X' -- любое строкое имя несуществующей таблицы, используемое (наверно) как разделитель
                   для задания имён столбцов (name_1 и name_2),
                   которые далее используются для вывода (или вычислений) в операторе SELECT
                Прим.: вывести разницу между суммой первого столбца и средним арифметическим второго
                    SELECT SUM(name_1) - AVG(name_2) FROM (VALUES ROW(1, 10), ROW(2, 20)) X(name_1, name_2) \G;
                    -> -12.0000

            > UPDATE
                EN: https://dev.mysql.com/doc/refman/8.0/en/update.html
                RU: http://www.mysql.ru/docs/man/UPDATE.html
                >> позволяет менять значения полей в уже существующих записях
                Прим.:
                    UPDATE catalogs SET name = 'Процессоры (Intel)'
                        WHERE name = 'Процессоры';
                    UPDATE users SET 
                        fullname = (SELECT fullname FROM profiles WHERE user_id = users.id);
                    -- переносим поле из связанных по ключу 1 к 1 таблиц.
            > DELETE
                EN: https://dev.mysql.com/doc/refman/8.0/en/delete.html
                RU: http://www.mysql.ru/docs/man/DELETE.html
                >> удаление по записи (в соответствии с условиями)
                    *** не обнуляется авто-инкремент
                    Примеры.
                    все (но по одной и долго)
                        DELETE FROM catalogs;
                    или не все
                        DELETE FROM catalogs LIMIT 2; /* удаляем какие-то 2-е записи */
                    или по условию
                        DELETE FROM catalogs WHERE id > 1 LIMIT 1;
            > TRANCATE
                EN: https://dev.mysql.com/doc/refman/8.0/en/truncate-table.html
                RU: http://www.mysql.ru/docs/man/TRUNCATE.html
                >> очистка таблицы TRANCATE
                    * без условий
                    * быстро
                    * обнуляется счётчик AUTO_INCREMENT
                    Пример:
                        TRANCATE catalogs;
            > INSERT и SELECT
                >> извлечение с одновременным добавление в другую таблицу
                    INSERT INTO 
                        catalog_1 
                    SELECT 
                        * 
                    FROM catalog;
            > INSERT и UPDATE 
                >> пытаемся добавить запись, а если не получатеся (она уже сеть), то обновяем
                    INSERT ... ON DUPLICATE KEY UPDATE Statement
                Прим.: таблица имеет второй ключ и с ним может быть проблема (такое значение уже есть) -- тогда обновляем
                    INSERT INTO users (listid,email,age,name) VALUES 
                        (3,'vit9@gmail.com',26,"Витя"),
                        (3,'kat9@gmail.com',32,"Катя"),
                        (3,'masha@gmail.com',29,"Маша"),
                        (2,'vit9@gmail.com',25,"Витя"),
                    ON DUPLICATE KEY UPDATE                 -- запись уже есть с таким ключём, 
                        listid=VALUES(listid),              -- поэтому обновляем даже все поля, 
                        email=VALUES(email),                -- в том числе и ключевое (на то же значение)...
                        age=VALUES(age),                    -- Но, наверное, можно искючить обновление ключевого поля
                        name=VALUES(name);                  -- в этой конструкции
            > REPLACE INTO test VALUES(1,...)
                >> если запись есть с таким ключём (в нашем сл. -- 1), то вначале удаляет её, 
                   а потом вставляет новую командой INSERT 
                >> если записи нет с таким ключём, то сразу вставляет новую, 
                   то есть работает как INSERT

Генерация данных
    -- Сервисы для генерации данных:
        http://filldb.info/
        http://www.generatedata.com/
        https://sourceforge.net/p/benerator/wiki/Home/
        http://www.dominicgiles.com/datagenerator.html

Изменения таблицы
    ALTER TABLE profiles ADD CONSTRAINT fk_profiles_user_id FOREIGN KEY (user_id) REFERENCES user(id);
        -- ограничение (constraint) целостности, DLL-команда
        -- сязать 1--1 таблицы "profiles(user_id)" и "users(id)" по указанному в скобках полу и главным является user(id)

    ALTER TABLE profiles ADD COLUMN birthday DATETIME;
        -- добавить колонку

    ALTER TABLE profiles RENAME COLUMN birthday TO date_of_birth;
        -- переименовать колонку

    ALTER TABLE profiles DROP COLUMN date_of_birth;
        -- удалить колонку

    ALTER TABLE profiles MODIFY field_name CHAR(50);
    ALTER TABLE messages MODIFY from_user_id BIGINT UNSIGNED NOT NULL;
        -- изменяем тип поля

    ALTER TABLE friend_requests ADD CHECK (id_1 <> id_2);
        -- добавляем проверку: поля id_1 и id_2 не могут быть равны

    ALTER TABLE users AUTO_INCREMENT=21;
        -- установить стартовую позицию автосчётчика для следующей новой строки в 21.
        -- может потребоваться, если таблица обнулялась и...

    ALTER TABLE profiles ADD CONSTRAINT fk_profiles_user_id FOREIGN KEY (user_id) REFERENCES users(id);
        -- добавить связь

    ALTER TABLE profiles DROP CONSTRAINT fk_profiles_user_id;
        -- удалить связь


ОПЕРАТОРЫ, ВЫБОРКИ, ФУНКЦИИ
    Арифметические операторы
        + -- сложение
            SELECT 2 + 5 ;
            или
                SELECT '2' + '5' ;
                -- строки будут преобразованы в числа автоматически...    
            или
                SELECT 'ыва' + 'sldkf' ;
                -- если строка не может быть преобразована в число, то она принимается равной 0 (нулю).
        - -- вычитание (бинарный оператор)
                SELECT 2 - 5 ;
          -- изменение знака операнда (присвоение отрицательного значения) 
             (унарный оператор)
                SELECT -5 ;
        * -- умножение
                SELECT 2 * 5 ;
            -- если выходим за диапазон BIGIND то возвращается ОШИБКА!            
        / -- деление
            -- обычно
                SELECT 5 / 2 ;
            -- на ноль возвращает NULL (а НЕ ОШИБКУ)
                SELECT 5 / 0 ; 
                > NULL
        %, MOD, MOD() -- остаток от деления
                SELECT 5 % 2 ;
            или 
                SELECT 5 MOD 2 ;
            или с использованием функции
                SELECT MOD(5, 2) ;
        DIV -- целочисленное деление
                SELECT 5 DIV 2 ;
        Внимание: 
            все операции с NULL результатом имеют NULL

    Операторы сравнения 
        -- возвращается 0 или 1
        -- возвр. NULL, при обычном (небезопасном) сравнивании с NULL
        TRUE, FALSE -- логические константы == псевдонимы 1 (TINYINT) и 0 (TINYINT)
        NOT, ! -- логическое отрицание
            SELECT NOT 1 > 2 ;
            SELECT ! 1 > 2 ;
        > -- больше
            SELECT 1 > 2 ;
            mysql> 0
        >= -- больше или равно: порядок знаков важен! (чтобы не перепутать с присваиванием, наверное)
            SELECT 1 >= 1 ;
            mysql> 1
        < -- меньше
        <= -- меньше или равно
        = -- равно
            SELECT 1 = NULL ;
            mysql> NULL
        !=, <> -- не равно
        <=> -- безопасное равно (на случай, если попадётся NULL)
            SELECT NULL <=> NULL ;
            mysql> 1
        IS -- классическое безопасное сравнение с NULL (только)
            SELECT 1 IS NOT NULL ;
            mysql> 1

    Логические операторы
        OR
        AND 
            -- имеет приоритет перед OR
            -- () -- скобки для изменения приоритета

    Выборки, ключевые слова
        WHERE: условие для выборки
            SELECT * FROM t WHERE id >= 3 AND id <= 7 ;
        IN(): в списке
            SELECT * FROM t WHERE id IN(3, 4, 5, 6, 7) ;
            SELECT * FROM t WHERE id IN(3, 4, 5, 6, 7, NULL) ; 
                -- вернёт в том числе и NULL (и все строки будет пропущены, так как NULL не равен NULL)
        BETWEEN--AND: в диапазоне:
            SELECT * FROM t WHERE id BETWEEN 3 AND 7 ;
            SELECT * FROM t WHERE id NOT BETWEEN 3 AND 7 ;
        LIKE: выборка похожих элементов (строк)
            SELECT 'программа' LIKE 'про%'
                где % -- любое количество символов
                или _ -- только 1-ин символ
        RLIKE (REGEXT, синоним) -- регулярные выражения для поиска
            -- удобные
            -- медленно выполняются
            -- виды:
                ^ -- начало строки;
                $ -- символ конца строки;
                | -- альтернатива, логическое ИЛИ;
            -- классы (для задания используются квадратные скобки)
                [abc] -- класс символов, список  (выбирается по одному и сравнивается);
                Пример: 
                    [a-w] -- список, заданный диапазоном;
                    [а-яё] -- список всех символов кирилицы, 
                              при этом "ё" не входит в этот диапазон и задаётся отдельно (особенность кодировки);
                    [0-9] -- все цифры
                [[:digit:]] -- класс любых цифр, соответствует одному цифровому символу
                [[:alpha:]] -- класс любых букв
            -- квантификаторы, указываются сразу после квадратных скобок класса
                ? -- символ входит 0 или 1 раз в строку;
                * -- символ входит 0 или более раз (любое количество);
                + -- символ входит 1 или более раз;
                {n} -- точное указание n-количества символов
            Пример:
                '[0-9]*' -- любое количество цифр, в том числе и нисколько
                '[0-9]+' -- количество от 1-ой и более любых цифр
                '\\.' -- знак десятичной точки (экранирование выполняется 2-я слешами)
                '[.|,]{1} -- тоже самое, но с запятой
                '[0-9]{2}' -- только две цифры (не больше и не меньше)
                '[0-9]+[.]{1}[0-9]{2}' -- десятичное числе, напр. 123.56
                SELECT '12345.67' RLIKE '[0-9]+[.]{1}[0-9]{2}' ; -- находим цену
            Пример:
                SELECT birthday_EN FROM users WHERE birthday_EN RLIKE 'may|august';
                -- где birthday_EN является строкой даты в каком-то нестандартном формате
                   с указание месяцев словами по английски и мы хотим найти даты с 'may' и 'august'
            Примеры:
            -- найти вхождение последовательности 'грам' в словах 'программа' и 'граммпластинка'
                SELECT 'программа' RLIKE 'грам', 'граммпластинка' RLIKE 'грам' \G
                * везде найдено, результат ИСТИНА
            -- найти подстроку в слове с начала строки ("крышечка")
                SELECT 'граммофон с пластинками' RLIKE '^грам' ;
                * найдено, результат ИСТИНА
            -- найти подстроку в слове с конца строки ("доллар")
                SELECT 'граммофон и пластинка' RLIKE 'пластинк$' ;
                * не найдено, результат ЛОЖЬ
            -- найти подстроку как самостоятельную строку ("$" и "^")
                SELECT 'граммофон и пластинка' RLIKE '^пластинка$' ;
                * не найдено, результат ЛОЖЬ
                SELECT 'пластинка' RLIKE '^пластинка$' ;
                * найдено, результат ИСТИНА
            -- найти символы из списка (a или b или c):
                SELECT 'a' RLIKE '[abc]' ; 
                * найдено, результат ИСТИНА
                SELECT 'w' RLIKE '[abc]' OR '[w]' ; 
                * не найдём -- неверная конструкция
                SELECT 'w' RLIKE '[abcw]'; 
                * найдём!
            

    Сортировка и выборка
        -- сортировка:
            ORDER BY поля через запятую [DESC] 
            Прим.:
                SELECT * FROM users ORDER BY firstname ASC, lastname; -- сортировка
                SELECT * FROM users ORDER BY firstname DESK, lastname DESK; -- с-ка в обратном порядке
        -- сортировка в заданном порядке (например IN(...)):
            SELECT * FROM users WHERE id IN(5, 1, 2) ORDER BY FIELD(id, 5, 1, 2)
        -- выборка с ограничением количества строк или по страницам:
            LIMIT n; где n -- количество выводимых строк, 
                     всегда последнее
                Прим.:
                    SELECT * FROM users ORDER BY firstname LIMIT 2; -- вывод только 2-х записей
            LIMIT p, n; где р -- позиция с которой начинается выбрка следующей страницы
                Прим.:
                    SELECT * FROM users ORDER BY firstname LIMIT 2, 2; -- вывод только 2-х записей 2-ой страницы
                    SELECT * FROM users ORDER BY firstname LIMIT 4, 2; -- вывод только 2-х записей 3-ой страницы
            LIMIT n OFFSET p; аналог предыдущего
        -- выборка только уникальных значений:
            DISTINCT -- указывается перед именем столбца
                Прим.:
                    SELECT DISTINCT firstname FROM users;
                    * вывод только уникальных имён
                    SELECT DISTINCT firstname, lastname FROM users;
                    * уникальными являются сумма имени и фамилии,
                      а не по отдельности
        -- выборка всех значений:
            ALL -- выводим все значения (в т.ч. и повторяющихся), 
                   по умолчанию
                Прим.:
                    SELECT ALL firstname FROM users;
                   или (тоже самое)
                    SELECT firstname FROM users;

        -- GROUP BY
            ...см. далее...

    Функции (https://dev.mysql.com/doc/refman/5.7/en/functions.html)
        Время
            time -- тип данных:
                > тип строковый, в формате:
                    >> 'hh:mm:ss' формат (or 'hhh:mm:ss' format for large hours values)
                > диапазон: 
                    >> от '-838:59:59' до '838:59:59'
                    >> от '-838:59:59.000000' to '838:59:59.000000'
            date -- тип данных:
                > 
            datetime -- тип данных:
                > ... 

            NOW(fsp) -- текущее время и дата
                https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_now
                -- возвращает постоянное время от начала выполнения запроса
                -- вычисляются одни раз для всех вызовов в рамках одного запроса
                    > время одинаков для всех вызовов в одном запросе
                    > имеет детерминированный (предсказуемый) характер
                    > может использоваться для транзакций (не проверено)
                    > может использоваться для индексов
                -- тип зависит от контекста использования:
                    > строка 'YYYY-MM-DD hh:mm:ss' -- строка в строковом контексте
                        Прим.: 
                            SELECT NOW();
                            -> '2022-05-19 15:22:21'
                    > число (тип???), в числовом контексте
                        Прим.:
                            SELECT NOW() + 0;
                            -> 20220519152210
                -- fsp точность от 1 до 6 знаков секунд, если указана
                Синонимы:
                    CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP
                    LOCALTIME(), LOCALTIME
                    LOCALTIMESTAMP(), LOCALTIMESTAMP
                Прим., задание времени созданий и обновлений полей таблицы:
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                Прим.:
                    SELECT NOW(), SLEEP(2), NOW();
                    -> 2006-04-12 13:47:36 |        0 | 2006-04-12 13:47:36 
                    -- время НЕ изменилось

            SYSDATE(fsp) -- время и дата для текущего запроса
                -- то же самое, что и NOW(), но время в запросе разное!
                -- не детерминирован
                    > не может использоваться в транзакциях
                    >  индексы не могут использоваться для вычисления выражений, которые ссылаются на него
                Прим.:
                    SELECT SYSDATE(), SLEEP(2), SYSDATE();
                    -> 2022-05-19 15:33:21 |        0 | 2022-05-19 15:33:23
                    -- время ИЗМЕНИЛОСЬ
                -- сделать псевдонимом NOW(): параметр --sysdate-is-now
                    > работает как для источника, так и для реплики

            DATE(строка) -- дата из строки
                Прим.: такущая дата как строка (формат не знаем)
                    SELECT DATE(NOW()) ;
            DAYOFYEAR() -- день в году, то есть номер дня от начала года

            TIME(expr) -- время из строки
                -- expr: тип time или тип date (формат) -- см. ниже
                -- тип: 
                -- тип возврата зависит от контекста использования:
                    > число, в арифметическом выражении
                    > строка
                    Прим.: 
                        SELECT TIME('2003-12-31 01:02:03') ;
                        -> '01:02:03'
                        SELECT TIME(NOW()) ;
                        -> '15:50:30'
                    Пример ошибки:
                        SELECT TIME(NOW()+59)) ; -- ОСТОРОЖНО С ВЫЧИСЛЕНИЯМИ
                        -> NULL

            TIMEDIFF(exp1, exp2) типа time или datetime
                -- возвращает разницу во времени (exp1 - exp2) 
                -- возвращает тип time или datetime
                -- тип аргументов: time или date
                    > аргументы должны быть одного типа 
                Примеры с ошибками:
                    SELECT TIMEDIFF((NOW()+59), (NOW()+0));
                    -> NULL
                    SELECT TIMEDIFF((NOW()+100), NOW());
                    -> 00:01:00
                    ВНИМАНИЕ! Секунды десятичные в таком использовании...

            TIMESTAMP(expr) -- возврат тип date или datetime
                -- expt: date или datetime
                Пример:
                    SELECT TIMESTAMP('2003-12-31');
                    -> '2003-12-31 00:00:00'
            TIMESTAMP(expr1, expr2) -- сложение даты и времени
                -- возврат: тип date или datetime
                -- складывает: expr1 + expr2 (в таком порядке)
                Прим.:
                    SELECT TIMESTAMP('2003-12-31 12:00:00','12:00:00');
                    -> '2004-01-01 00:00:00'

            TIMESTAMPADD(unit, interval, datetime_expr) -- типа date
                -- приращение даты на целочисленный interval, 
                   в указанных единицах измерения unit
                -- Временные интервалы (unit):
                   (https://dev.mysql.com/doc/refman/8.0/en/expressions.html#temporal-intervals)
                    > MINUTE
                    > HOUR
                    > DAY
                    > WEEK
                    > YEAR
                    > MONTH
                    > QUARTER
                    > DAY_SECOND -- 'DAYS HOURS:MINUTES:SECONDS'
                    > DAY_MINUTE -- 'DAYS HOURS:MINUTES'
                    > DAY_HOUR -- 'DAYS HOURS'
                    > YEAR_MONTH -- 'YEARS-MONTHS'
                Пример:
                    SELECT TIMESTAMPADD(HOUR, 1, '2022-05-1');
                        -> 2022-05-01 01:00:00
                    SELECT TIMESTAMPADD(WEEK, 10, '2022-05-1');
                        -> 2022-07-10
                    SELECT TIMESTAMPADD(YEAR, 1, '2022-05-1');
                        -> 2023-05-01

            ADDDATE(expr, days)
                -- добавляет дни к дате
                -- синоним DATE_ADD()
                Прим.:
                    SELECT ADDDATE('2008-01-02', 31);
                        -> '2008-02-02'
            ADDDATE(date, INTERVAL expr unit)
                -- добавляет дни к дате
                -- unit, "Временные интервалы", см. выше или (https://dev.mysql.com/doc/refman/8.0/en/expressions.html#temporal-intervals)
                Прим.:
                    SELECT DATE_ADD('2008-01-02', INTERVAL 31 DAY);
                        -> '2008-02-02'
                    mysql> SELECT ADDDATE('2008-01-02', INTERVAL 31 DAY);
                        -> '2008-02-02'                

            TIMESTAMPDIFF(unit, datetime_expr1, datetime_expr2) типа ЦЕЛО ЧИСЛО
            -- возврат разницы: datetime_expr2 - datetime_expr1 в указанных единицах
            -- unit, единицы измерения результата (возврата функции):
                > YEAR
                > MONTH
                > MINUTE
            -- datetime_expr1-2 типа data или datatime
            Прим.:            
                TIMESTAMPDIFF(YEAR, birthday_at, NOW())
                    > разница в YEAR (годах, то есть)

            TIME_FORMAT()

            DATE_FORMAT(date, format) -- тип строковый
                -- обратная функция STR_TO_DATE()
                -- преобразует дату в строку в соответствии с форматом
                -- Спецификаторы формата
                    %D -- день в месяце с английским суффиксом (0th, 1st, 2nd, 3rd, …)
                    %w -- день в неделе цифрами, номера соответсвуют списку (0=Sunday..6=Saturday)
                    %d -- день (00..31) в месяце
                    %e -- день (0..31) в месяце
                    %M -- месяц, имя (January..December)
                    %m -- месяц (00..12)
                    %c -- месяц (0..12)
                    %Y -- год (ГГГГ)
                    %y -- год (ГГ)
                    %p -- AM или PM
                    %r -- время, 12-часовой формат с AM или PM на конце ('hh:mm:ss AM' или 'hh:mm:ssAM')
                    %T -- время, 24-часовой формат (hh:mm:ss)
                    %k -- часы (00..23)
                    %l -- часы (0..12) -- Внимание: значение 14 (часов) представляются как 2 (часа) -- AM/PM необходимо!!!
                    %i -- минуты (00..59)
                    %S -- секунды (00..59)
                    %s -- секунды (0..59)
                    %% -- символ "%"
                Пример:
                    SELECT DATE_FORMAT('2022-05-16 15:20:01', 'На дворе %Y год'); -- извлекаем из строки год...
                    -> 'На дворе 2022 год'
                    SELECT DATE_FORMAT('2022-05-16 15:20:01', '%e.%c.%Y %k:%i');
                    -> '16.5.2022 15:20'

            STR_TO_DATE(str, format)  -- типа datetime
                https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_str-to-date
                -- обратная функция DATE_FORMAT()
                -- любые несовпадения формата приводят к ошибке
                -- спецификаторы формата см. выше DATE_FORMAT()
                Пример с использованием изменённого формата и дополнительного текста:
                    SELECT STR_to_DATE('слово 31.01.2005; 07:15:25', 'слово %d.%m.%Y; %h:%i:%s');
                    -> 2005-01-31 07:15:25
                    SELECT STR_to_DATE('2.01.2005; 07:15:25', '%e.%m.%Y; %T');
                    -> 2005-01-31 07:15:25

            UNIX_TIMESTAMP() -- 4 байта, UNIX-время, количество секунд с 1.1.1970 по 2038 год
                -- может зависить от часового пояса, см. док...
            FROM_UNIXTIME() -- возврат секунд с 1.1.1970 в нормальное представление

            SECOND() -- Return the second (0-59)
            MINUTE() -- минуты
            HOUR(строка) -- час из строки

            DAY() -- синоним DAYOFMONTH()
            DAYOFMONTH(date), int
                -- число в месяце
                Пример:
                    SELECT DAYOFMONTH('2007-02-03');
                    -> 3
            DAYOFWEEK(date), тип INT
                -- возвращает номер (индекс) дня в неделе
                -- При этом 1--Sunday, 2--Monday, …, = Saturday
                Пример:
                    SELECT DAYOFWEEK('2007-02-03');
                    -> 7
                    *** ПРИМЕЧАНИЕ: 7 -- это суббота!!!
            DAYNAME(date) тип строковый
                -- название дня 
                Пример:
                    SELECT DAYNAME(STR_to_DATE('31.01.2005; 7:15:5', '%d.%m.%Y; %l:%i:%S'));
                    -> Monday

            MONTH(), INT
                -- возвращает месяц с даты
            MONTHNAME() -- название месяца, возвращает строковое значение
            YEAR(date) -- возвращает год
                -- год из даты
                -- date -- строго тип date
                Прим.:
                    SELECT YEAR(NOW());
                    -> 2022
                Пример с неточным заданием типа аргумента (как время, а не как дата):
                    SELECT YEAR('09:01:01');
                    -> 2009
            TO_DAYS(date) -- INT
                -- возвращает номер дня в году
                -- не применяется со значениями меньше 1582 года, то есть до появления григорианского календаря, так как не учитывае дни, которые были потеряны при смене календаря.
                -- см. какой календарь используется (https://dev.mysql.com/doc/refman/5.7/en/mysql-calendar.html)
                Прим.:
                    SELECT TO_DAYS(950501);
                    -> 728779
                    SELECT TO_DAYS('1995-05-01');
                    -> 728779
                    SELECT TO_DAYS('2007-10-07')
                    -> 733321
            TO_SECONDS(expr) тип INT
                -- возвращает количество секунд он начала года
                -- expr типа date или datetime
            SEC_TO_TIME(seconds) тип time
                -- преобразует колиество секунд в сутках во время
                Пример:
                    SELECT SEC_TO_TIME(2378);
                    -> '00:39:38'

            ??? MAKEDATE() -- Create a date from the year and day of year
            ??? MAKETIME() -- Create time from hour, minute, second

        Информационные
            VERSION() -- версия SQL
                SELECT VERSION();
               или тоже самое с пустой (несуществующей) таблице
                SELECT VERSION() FROM DUAL;
            DATABASE() -- текущая база данных
                SELECT DATABASE();
                > NULL -- если база не выбрана
            USER() -- текущий пользователь
            
        Счётчик автоинкремента
            LAST_INSERT_ID() -- Авто-счётчик, последнее значение счётчика авто-инкремента...
                Пример:
                    INSERT INTO catalogs VALUES (NULL, 'Процессоры'); 
                    -- авто-счётчик срабатывает и принимает последнее значение
                    INSERT INTO products (name, description, price, cataloge_id) 
                    VALUES ('Intel Core i3-8100', 'Процессор Intel.', 7890.00, LAST_INSERT_ID()); 
                    -- использование последнего значения для указания последнего нового id из "catalogs".

        Математические
            RAND() -- случайное...
                SELECT * FROM users ORDER BY RAND();
                -- вывод записей в случайном порядке
                SELECT * FROM users ORDER BY RAND() LIMIT 1;
                -- вывод каждый раз отличной записи
            SQRT(n) --  квадратный корень числа n
            POW(n, s) -- возведение числа n в степень s
            ROUND(f) -- округление f до ближайшего целого
            CEILING(f) -- округление f до ближайшего большего целого
            FLOOR(f) -- округление f до ближайшего меньшего целого
            SIGN() -- знак числа
            MOD() -- деление по модулю
            SIN(RADIANS(angle)) -- синус и аргумент в радианах...
            LOG(N) 
                -- логариф натуральный
                -- N < 0 неопределено и возвращает NULL
                -- сумма логарифмов равна логорифму произведения
                   ln(2*3*4*5) = ln(2) + ln(3) + ln(4) + ln(5)
                   Пример:
                    SELECT value
            EXP(N) 
                -- экспанента натуральному логарифму
                -- обратная операция логарифму
                   n = exp(ln(n))
                Пример:
                    SELECT EXP(LOG(10));
                    -> 10
                Пример: произведение двух значений используя сумму:
                    SELECT EXP(LOG(10) + LOG(10))
                    -> 100
                Пример: произведение столбца (с агрегирующей ф. SUM())
                    SELECT EXP(SUM(LOG(value))) FROM tbl WHERE id > 0 ;

        Строковые
            https://dev.mysql.com/doc/refman/8.0/en/string-functions.html
            SUBSTRING('строка', 1, 5) -- выборка из строки символов с 1-ого (начало, всегда с 1-цы) по 5-ый
            REPLACE() -- Замена вхождений указанной строки
            CONCAT('string-1', 'str-2'), строковое
                -- объединение (сложение) множества подстрок
                Пример:
                    SELECT CONCAT('string-1', '.', 'str-2', '.', 'str-3');
                    -> 'string-1.str-2.str-3'
            CONCAT_WS() -- строковое
                -- объединение строк с разделителем
                Пример:
                    SELECT CONCAT_WS('.', 'string-1', 'str-2', 'str-3');
                    -> 'string-1.str-2.str-3'
                    SELECT CONCAT_WS(',','First name',NULL,'Last Name');
                    -> 'First name,Last Name'
            FIELD('зн-0', 'зн-1', 'зн-2', 'зн-3')
                -- обратная ELT()
                -- созвращает позицию (индекс) вхождения значения из списка в строке
                    > если равно, то > 0 (истина);
                    > не найдено или NULL возвращает 0 (ложь).
                Пример. Сортировка выборки в порядке IN(...):
                    SELECT id, name FROM users WHERE id IN (2, 3, 1) ORDER BY FIELD(id, 2, 3, 1);
            ELT(N, str1, str2,...)
                -- обратная FIELD()
                -- возвращает строку по номеру N (начальный агргумент)
            FIND_IN_SET(str, list)
                -- возвращает индекс (позицию) подстроки str в длинной строке str_list с разделителями
                -- сама подстрока поиска не должна иметь разделитель.
                Пример:
                    SELECT FIND_IN_SET('b', 'a,b,c,d');
                    -> 2
            INSTR(str, substr)
                -- возвращает положение первого вхождения подстроки (substr) в строке (str)
                -- аналог LOCATE() с двумя аргументами (порядок обратный)
                Пример:
                    SELECT INSTR('foobarbar', 'bar');
                        -> 4
                    SELECT INSTR('xbar', 'foobar');
                        -> 0

        Преобразования типов
            BINARY -- приведение строки в двоичной формате
            CAST(expr AS type) [charset_info] -- возвращает значение типа type
                -- преобразование типа expr в тип type
                -- charset_info -- если есть, то тип наборов символов для строки
                -- типы (type):
                    > BINARY[(N)]
                    > CHAR[(N)] -- создаёт VARCHAR-строку
                    > DATE -- тип "дата"
                    > DATETIME -- тип "дата-время"
                    > TIME[(M)] -- создаёт тип time с точночтью M дробных секунд
                    > DECIMAL[(M[,D])] -- создаёт десятичное значение
                    > SIGNED [INTEGER] -- создаёт BIGINT
                    > UNSIGNED [INTEGER] -- создаёт беззнаковое значение BIGINT
                    > JSON -- см. доп. док. (https://dev.mysql.com/doc/refman/5.7/en/json.html#json-comparison)
                    > NCHAR[(N)] -- создаёт строку с национальным набором символов,... см. док. (https://dev.mysql.com/doc/refman/5.7/en/charset-national.html)
            CONVERT(expr, type) -- (соответствует CAST)
            CONVERT(expr USING transcoding_name)
                -- преобразует данные между различными наборами символов.
                Прим.:
                    SELECT CONVERT('abc' USING utf8);
                    -> abc
                    SELECT CONVERT('слово' USING ASCII);
                    -> ?????

        Логические
            IF(условие, значение-истина, значение-ложь)
                -- функция
                -- выдаёт тип в соответствии с аргументами
                -- логическое выражение не должно быть строковым,
                   так как строка всегда имеет значение TRUE
                   (то есть в кавычки условие брать нельзя!)
                Пример: выдача значения
                    SELECT IF(1 < 2, 'правда', 'ложь') 
                    -> 'правда'
                Пример: изменение порядке сортировки
                    SELECT total FROM order_products ORDER BY IF(total > 0, total, 18446744073709551615);
                    -- сначала все значения в порядке возрастания,
                       а последним нулевое значение!

            CASE -- целая конструкция
                Прим.: изменяем значения при выводе (EN на RU)
                    SELECT
                        CASE
                            WHEN firstname = 'Ivan' THEN 'Ваня'
                            WHEN firstname = 'Mikl' THEN 'Миша'
                            ELSE 'неизвестный'
                        END AS ru_name
                    FROM users;

        Всмопогательные
            INET_ATON('192.168.1.1') -- преобразование адреса в число
            INET_NTOA( 3232235777) -- обратно...
            UUID() -- универсальный глобальный уникальный идентификатор во времени и пространстве

    Использование операторов: 
        Вычисляемые поля
            CREATE TABLE _t1 (
                x INT, 
                y INT, 
                s INT AS (x + y) ) ; -- поле не сохраняется на диске и не индексируется
        Вычисляемое с сохранением на диске
            CREATE TABLE _t1 (
                x INT, 
                y INT, 
                s INT AS (x + y) STORED ) ; -- теперь это поле индексируется!

        Условия
            SELECT * FROM catalogs WHERE id_catalog > 2 ;
            SELECT * FROM catalogs WHERE id_catalog > 2 AND id_catalog <= 4 ;
        или тоже самое с конструкцией BETWEEN--AND
            SELECT * FROM catalogs WHERE id_catalog BETWEEN 3 AND 4 ;
        Примеры со временем:
            -- родившиеся в 90-ые годы:
                SELECT * FROM users WHERE birthday_at >= '1990-01-01' AND birthday_at <= '2000-01-01' ;
               или (тоже самое)
                SELECT * FROM users WHERE birthday_at BETWEEN '1990-01-01' AND '2000-01-01' ;
               или
                SELECT * FROM users WHERE birthday_at LIKE '199%' ;
        IN-конструкция со списком (...)
            -- возвращает:
               > TRUE, если значение имеется в списке, 
               > FALSE, если значение отсутствует
               > NULL, если ищется NULL:
                    SELECT NULL IN(2, 3, 5, NULL);
                    > NULL
            -- возвращает NULL, если
            SELECT * FROM catalogs WHERE id_catalog IN (1, 2, 5, NULL) ;
            SELECT * FROM catalogs WHERE id_catalog NOT IN (1, 2, 5, NULL) ;

Группы
    а. GROUP BY ... -- собственно, группировка!
    б. теперь сортировка!
    в. LIMIT -- вообще самое последнее, если есть...

    SELECT COUNT(*) AS Total,                     -- количество в группе
           SUBSTRING(birthday_at, 1, 3) AS decade -- десятилетие рождения (декада)
        FROM 
           users
        GROUP BY    -- группировка
           decade   -- по декаде
        ORDER BY
           decade
        LIMIT 2 ; 

    Список значений поля в группе (их список):
        GROUP_CONCAT() 
            -- ф-ция, выводящая все значения в группе в строку
            -- максимум 1000 символов (если не указано в параметрах сервера БД иное)
                SET SESSION group_concat_max_len = 4; 
                    > всего 4-е записи в списке на текущую сессию
                    > значение >= 4.
                    > по 2-а (байта) на каждый символ Юникода.
                SET SESSION group_concat_max_len = 1024; 
                    > умолчание
                SET GLOBAL group_concat_max_len = 1024; 
                    > глобально, потребуется рестарт
            Прим. исп.:
                GROUP_CONCAT(users) 
                    -- через запятую и без пробела (по умолчанию)
                GROUP_CONCAT(users SEPARATOR ' ') 
                    -- разделитель -- пробел
                GROUP_CONCAT(users ORDER BY name DESC SEPARATOR '; ') 
                    -- с сортировкой в обратном порядке
                GROUP_CONCAT(DISTINCT users ORDER BY name DESC SEPARATOR '; ') 
                    -- ...только уникальные
        Пример:
            SELECT 
                COUNT(*) AS Total,                     -- количество в группе
                GROUP_CONCAT(name ORDER BY name DESC SEPARATOR ', '),
                SUBSTRING(birthday_at, 1, 3) AS decade -- десятилетие (декада)
            FROM 
                users
            GROUP BY    -- группировка
                decade   -- по декаде
            ORDER BY
                decade
            LIMIT 2 ; 

    HAVING 
        -- условия для групп
        -- можем использовать агрегационные функции (с WHERE это невозможно, так как оно исп. до группы)
            Прим.:
                SELECT 
                    COUNT(*) AS Total,
                    GROUP_CONCAT(name ORDER BY name DESC SEPARATOR ', '),
                    SUBSTRING(birthday_at, 1, 3) AS decade
                FROM 
                    users
                GROUP BY            -- группировка
                    decade          -- по декаде
                HAVING 
                    total >= 2      -- только группы, в которых более 1-ой позиции
                ORDER BY
                    decade
                LIMIT 2 ; 
        -- можно и без группы, но использовать псевдонимы (с WHERE это не получиться):
            Прим.:
                SELECT firstname, lastname, DATE_FORMAT(birthday, '%M') AS b_month FROM users, profiles 
                WHERE users.id=profiles.user_id HAVING b_month IN('may', 'august');

    WITH ROLLUP
        -- дополнение к GROUP BY field_name_grp
        -- возвращает полный список всех field_name_grp для всех групп
        -- работает и для поля count(...) -- возвращает общую сумму всех агрегаций
        -- для всех остальных полей возвращается NULL
        -- сортировка в этом случае не применима.

    ??????????????????????????????????????

    https://learndb.ru/
    Определение задания значения ???
        GROUPING(field_name) -- определение NULL
        -- возвращает 0 (FALS), если значение есть;
        -- возвращает 1 (TRUE), если значение NULL;
        -- может использоваться с функцией IF(...) для изменения значения


Агрегация данных при помощи функций (для работы с группами, лекция 05) 
    https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html
    -- функции задаются только после SELECT
       > использовать в выражении WHERE нельзя!!!
    -- выполняется при помощи агрегатных функций
    -- возвращают значение для группы
       > если группа не задана, то вся таблица принимается как одна группа
    COUNT(fild_name)
        -- возвращает количество строк (записей) в группе
        -- исключает NULL (не считает их)
        -- если "*", то количество включает поля NULL
    COUNT(DISTINCT fild_name)
        -- подсчитываются только уникальные значения поля
    
    MIN(fild_name)
        -- минимальное зн-ие в группе
    MAX(field_name)
        -- максимальное...

        Пример: как вывести максимальное значение?
            Это ошибка:
                SELECT * FROM products WHERE price = MAX(price);
            А это правильно:
                SELECT * FROM products ORDER BY price DESC LIMIT 1;

    AVG(field_name)
        -- среднее значение в группе

    SUM(field_name)
        -- сумма всех значений столбца
        -- NULL игнорируется

    ANY_VALUE(field_name)
        -- агрегационная функция-затычка
        -- используется для вывода случайного значения из сгрупированного списка
        Прим.:
            SELECT ANY_VALUE(name)




JSON
    -- См. так же описание типов (выше).
    CREATE TABLE distances (
        id SERIAL PRIMARY KEY,
        a JSON NOT NULL,
        b JSON NOT NULL,
        dist DOUBLE AS (a->>'$.x' - b->>'$.x')
    );
    где
        a = '{"x":7}'
        b = '{"x":5}'
        $ -- обозначение вершины коллекции JSON
        ->> -- доступ в поле к элементу коллекции

Info
    SELECT VERSION();  -- вывести версию сервера.
    SHOW DATABASES; -- вывести базы данных на сервере.
    SHOW TABLES; -- вывести таблицы в текущей базе.
    SHOW WARNINGS; -- вывод последней ошибки
    SHOW VARIABLES LIKE 'port' -- порт из меременных
    STATUS -- статус (выбранная база, ...)
    DESCRIBE tablename; -- структура таблицы

?-?-? ОТКРЫТЫЕ ВОПРОСЫ ?-?-?#

Источники
https://dev.mysql.com/doc/refman/5.7/en/tutorial.html

https://dev.mysql.com/doc/refman/5.7/en/literals.html

Линн Бейли. Head First. Изучаем SQL. — СПб.: Питер, 2012. — 592 с.

Грофф, Джеймс Р., Вайнберг, Пол Н., Оппель, Эндрю Дж. SQL: полное руководство, 3-е изд. :Пер. с англ. — М.: ООО "И.Д. Вильямс", 2015. — 960 с.

...



2022-05-14. Практическое занятие


# END