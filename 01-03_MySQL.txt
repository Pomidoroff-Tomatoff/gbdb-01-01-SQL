MySQL (2022.04.08--22.05.04)

Литература по СУБД:
    Руководство по оформлению кода в SQL: 
        https://www.sqlstyle.guide/ru/
    «Изучаем SQL», Линн Бейли
    «Введение в системы баз данных», Крис Дж. Дейт
    «Изучаем SQL», Алан Бьюли
    «SQL. Сборник рецептов», Энтони Молинаро
    Учебник по SQL: 
        https://learndb.ru/ (другие курсы)

Другие курсы: https://learndb.ru/

СТРУКТУРА КУРСА:
Вебинар: интерактиное занятие с преподавателем.
Лекция (видео-урок) можно посмотреть сразу, как он станет доступен -- обычно в тот же день, что и...
ДЗ: надо сдать в течении 7 дней, но можно отложить ещё на неделю. Для этого нужно указать "сдам позже" (преподаватель ставит "не сдано" и ждёт, когда ученик сделает и сдаст ДЗ)
     1. ВЕБИНАР Установка и знакомство
     2.  лекция DDL: Управление БД. Язык запросов SQL.
     3. ВЕБИНАР DDL: Введение в проектирование БД.
                     DDL + CREATE, ALTER, DROP
     4. ВЕБИНАР DML: CRUD-операции (создание, чтение, обновление, удаление).
     5.  лекция SELECT: Операторы, фильтрация, сортировка и ограничение. Агрегация данных.
     6. ВЕБИНАР SELECT: --//--
     7.  лекция SELECT, JOIN: Сложные запросы
     8. ВЕБИНАР SELECT, JOIN: Сложные запросы (28.05.2022)
    >>> продвинутый материал <<< на этом курс прервался
     9.  лекция Транзакции, переменные, представления. (28.05.2022)
                Администрирование.
                Хранимые процедуры и функции.
                Тригеры.
    10. ВЕБИНАР --//--
        > ДЗ: предварительная версия курсового
    11.  лекция Оптимизация запросов.
                NoSQL.
    12. ВЕБИНАР Оптимизация запросов.
    00. !!! КУРСОВАЯ РАБОТА !!!

Преподавательский состав
    Преподаватель вебинаров: Кирилл Иванов
    Лекции (видео-запись): Игорь Симдянов
    Наставник: Михаил Чирков
    Наставник: 
    Наставник: 
    
Telegram (это BigDATA):
    https://t.me/+cIo3krhbes01NjAy

Готовая виртуальная машина с Ubuntu v16 и MySQL 5.7: 
    https://yadi.sk/d/bS5Wm135JQYRkQ 
    (пароль от учетки Linux -- student: master)
    (пароль от учётки MySQL -- root: master)
Процесс установки виртуальной машины:
    https://yadi.sk/i/EH0MDN12xVm-pQ

DBeaver
    https://dbeaver.io/download/ 
    Настройки:
        encoding:  Data Editor -> Binary Editor: Text file encoding: UTF-8
        ... ещё см. ниже более подбробно

Установка MySQL
    Учебные базы данных MySQL:
        dev.mysql.com/doc/index-other.html
        Или: mysql.com -> documentation -> More -> Exqample Databases
        -- проектирование типовых решений:
            * employees (инфо по использованию
            * sakila     на ссылке "view")

        Установка:
            mysql> SOURCE C:/TEMP/sakila-db/sakila-schema.sql;
            mysql> SOURCE C:/TEMP/sakila-db/sakila-data.sql;

    MySQL под Windows
        -- последняя версия, для Windows 10 или выще:
            https://dev.mysql.com/downloads/mysql/
        -- для версии Windows, ниже 10-ой MySQL-8 может отказаться работать.
            * window 7: MySQL 5.7
            * старые версии MySQL: https://downloads.mysql.com/archives/community/
        -- установка всего по умолчанию
        -- сервер установить как службу и запустить при автозагрузке...
        -- пользователь root:
            USR: root
            PW: 12345
        -- можно сделать ещё одного пользователя...
        -- документация:
            mysql.com -> documentation -> MySQL Server -> + -> выбор версии
            https://dev.mysql.com/doc/
    MySQL в Mac OS/X
        -- требуется XCode (интегрированная среда разработки), нужны  
            * инстрменты командной строки
            * компилятор
            * проверка установки XCode:
                xcode-select -p /Applications/Xcode.app/Contents/Developer
                если что-то ни так
    MySQL под Linux Ubuntu
        -- необходимо обновить индексы пакетного менеджера apt-get:
            sudo apt-get update
        -- далее обновляем систему:
            sudo apt-get upgrade
        -- установка MySQL:
            sudo apt-get install mysql-server
        -- проверка установленного и запущенного сервера:
            ps aux | grep mysqld
            * процесс называется "mysql", а запущен "/usr/sbin/mysqld"
                или
            service mysql status
            * интересно, что служба называется "mysql.service"
        -- после установки необходима выполнить настройку:
            sudo mysql_secure_installation
            ...
    MySQL под Linux Ubuntu: запуск нескольких серверов одновременно
        -- утилита mysqld_multi и её особенности
        -- обычный запуск сервера как службы надо отключить

Настройка 
    Конфигурациия:
        https://dev.mysql.com/doc/refman/8.0/en/option-files.html
        -- файлы конфигурации и их расположение
        -- формат конф. файла, параметры и их значения

    Редактор настройки:
        mysql_config_editor
        https://dev.mysql.com/doc/refman/8.0/en/mysql-config-editor.html

Запуск MySQL:
    Windows, команда:
        mysql -u USER -p PASS  -- кажеться так
        * если (наверное) в домашнем каталоге пользователя 
          лежит файл my.cnf, то
    Конфиг, (https://dev.mysql.com/doc/refman/8.0/en/option-files.html)
    Windows: конфиг-файл с настройками пользователя(ей) по умолчанию:
        my.cnf -- в домашнем каталоге с явками и паролями, формат:
            [mysql] -- пока неизвестно, что за раздел, но какой-то важный
            user = root
            password = 12345

            [client] -- видимо, клиентская программа
            user = root
            password = 12345
    Linux, команда:
        mysql
    Linux, конфиг-файл в домашнем каталоге (~)
        .my.cnf -- начинается с точки, расположен в домашнем каталоге

IDE
    Workbench (MySQL)
    -- входит в поставку MySQL (Oracl)
    -- только MySQL серверы
    -- нативный (родной, местный) инструмент
        * можно управлять сервером как сервисом (запускать, останавливать)...
    -- ER Diagrams (ERR Diagram, ER диаграмма, ERR диаграмма):
        Database -> Reverse Engineer (или crtl + R) -> ...указать базу из списка... -> ER диаграмма
       или
        https://github.com/kolei/PiRIS/blob/master/articles/5_1_1_1_erd_workbench.md
    -- Safe Updates (rejects UPDATEs and DELETEs with no restrictions)
        > запрет удалений и обновлений без ограничений!
        > данный режим предполагает обязательное использование 
          условия WHERE с первичным ключом или указания оператора LIMIT;
            Пример, как надо: 
                UPDATE goods SET price = price + 10 WHERE product_id > 0;
                UPDATE goods SET price = price + 10 LIMIT 100;
        > используется для защиты от удаления всей таблицы
            >> забывают написать условие WHERE
            >> забывают написать ограничение LIMIT
        > Ошибка 1175 (MySQL Workbench Error Code: 1175) -- защита нарушения этого режима.
        > Отключение этого режима (обновления): 
            >> SET SQL_SAFE_UPDATES = 0; -- откл. на время сеанса
            >> MySQL Workbench «Edit -> Preferences -> SQL Editor: группа "Other", элемент "Safe Updates" = OFF (снять галочку)
               и переподключиться к базе (перезагрузить Workbench)
    -- Ограничение вывода на экран (вдимо, количества запросов за сеанс)
        > 50 чего-то по умолчанию...
            SQL Editor -> Query Editor: Prodactivity, Max number of result sets: 50
          ножно поменять на 101...


    DBeaver 
        https://progtips.ru/bazy-dannyx/menedzher-baz-dannyh-dbeaver.html#i
        https://cloudbeaver.io/ -- облако для работы с базами данных в HTML
    -- сайт: dbeaver.io
    -- поддерживает серверы: MySQL, PostegSQL,...
    -- бесплатный (Community Edition)
    -- горячие клавиши:
        Ctl + shift + L -- подсказа по клавишам!
        Ctrl + Space -- подсказки;
        Alt + X -- исплнить всё или выделенное;
        Ctrl + Enter -- исполнить выражение па строке с курсором;
        Ctrl + PgUp / Ctrl + PgDn -- навигация между вкладками.
        Ctrl + / -- переключение комментарий--код (однострочный)
        Ctrl+ Shift + / -- блочный комментарий
    -- ошибки:
        * Connect to (имя сервера): Public Key Retrieval is not allowed
          ** сервер MySQL не запущен: можно... воспользоваться Workbench, чтобы запустить его оттуда или запустить службу руками...
    -- кодировка: 
            General -> Workspace: (в панели параметров справа) Text file encoding = Other = UTF8
        или (тоже самое, но через поиск Preference)
            encoding:   Data Editor -> Binary Editor: 
                        Text file encoding = Other = UTF8 (переключить с умолчания на специально выбранное)
        или
            добавить ключ запуск в коммандную строку:
                -vmargs -Dfile.encoding=UTF8
    -- Стиль кода:
        https://question-it.com/questions/647923/kak-pomenjat-zaglavnye-bukvy-v-dbeaver
        > Место: Windows -> Preferences -> Editors -> SQL Editor -SQL Formatiing (форматирование):
            >> Регистр ключевых слов: Upper (и всё)
            >> Форматирование: "Стандартный"
        > complition (в строке поиска Preferences):
            >> SQL Editor -> Code Completion:
                * Insert case = Default
                * Replace current word = "turn-off", выкл.
        > formationg (в строке поиска Preferences):
            >> SQL Editor -> Formatting:
                * Keyword case: = Upper
            >> Formatter: Default formatter

    -- Список подключений, окно-докер слева: 
        * Window (Окна) -> DataBases (базы данных)
        * Создаём подключение (MySQL 8+ - 127.0.0.1): 
            > нажать вилку с "+" и выбрать MySQL в этом окне
              или на инструментальной панели или в меню 
            > Меню: База данных -> Новое соединение: 
                >> выбрать MySQL 
                >> хост...
                >> пользователя: root
                    и его пароль
    -- Перед началом работы с кодом (скриптом) нужно каждый раз выбирать подключение:
        * Текущее подключение (на инстументальной панели)
            > MySQL 8+ - 127.0.0.1
                >> если этого подключения нет, то создать его (см. выше)
            > Текущую базу данных (каталог, схему)
    -- Стиль оформления кода (принятого в среде программистов ):
        * https://www.sqlstyle.guide/ru/

    -- ER Diagrams <- View Database (разные свойства, в том числе и диаграмма)
        https://dbeaver.com/docs/wiki/ER-Diagrams/
        Window -> Show view -> Database Navigator (палитра слева со списком объектов, в том числе и баз) слева -> 
        -> Databases (список баз данных) -> 
        -> выбрать в списке базу и вызвать меню объекта (правая кнопка) ->
        -> в меню объекта пукт "View Database" (или F4)
        в правом окне получем строку со вкладками "Properties" и "ER Diagram".
    
    -- Update ERROR:
        не даёт обновлять записи, пока что-то не разрешишь это в 2-х разных окошках...        

    -- Mock Data Generator
        https://github.com/dbeaver/dbeaver/wiki/Mock-Data-Generation-in-DBeaver
        > инструмент для заполнения таблиц формальными (экспериментальными) данным как плагин для DBeaver
        > быстро и удобно
        > полный функционал (геренация элемтнонной почты и так далее) только для платных версий DBeaver (Enterprise and Ultimate editions only).

    DbForge (аналог DBeaver)
        https://www.devart.com/dbforge/mysql/studio/
        -- есть бесплатный
    phpMyAdmin
    -- среда для работы с серверами Apach...
    JetBrains DataGrip
    JetBrains pyCharm


Введение
    DDL -- Data Definition Language -- язык описания данных.
        * создание объектов: табличек, 
    DML -- Data Manipulation Language -- язык манипуляции данных.
        * СRUD-операции (Create, Read, Update, Delete)

Нормальные формы
    1 НФ: атомарный вид (то есть, максимально простой).
    2 НФ: отсутствие дублирований данных (используются ключевое поле для ссылки на данные).
    3 НФ: для каждой сущности реального мира своя справочная таблица.
    3+НФ: у таблицы может быть только один первичный ключ.
    4 НФ: ... (здесь не изучается)
    5 НФ: ...
    6 НФ: ...


БАЗЫ ДАННЫХ
    Типы
        -- Иерархические СУБД (самое простое, что приходит в голову)
            * деревью были хорошо изучены и готов мат-аппарат
            * невозможность организовать отношения многого ко многим
        -- Сетевые (графовые): ценность приобретают связи бежду узлами
            * сложность изменений
        -- Реляционные (Эдгар Кодд, 1970 г)
            * первая РСУБД Oracle -- 1979 год
    Производители:
        Коммерческие: Oracle, MS SQL, IBM DB2
        Некоммерческие: MySQL, PostgreSQL, Firebird
        Самые популярные: MS SQL и PostgreSQL.
    Индекс популярности использования БД:
        https://db-engines.com/en/ranking
    Развитие сети интернет (множестов пользователей и данных):
        -- распределённые БД: данные перестали умещаться на одном сервере
            * сложность реализации стандартного SQL
            * появление специализированных NoSQL:
                Redis, MongoDB, ElasticSearch, ClickHouse, Cassandra
            * шардирование: разделение данных на части, если они не влезают в ОЗУ на одном сервере
            * проблема: разрыв связи

    ОСНОВЫ РЕЛЯЦИОННЫХ БАЗ ДАННЫХ
        Таблица:
            -- должна содержать минимум один столбец
            -- может не содержать строк вообще (данных), тогда есть только шапка (описание структуры)
            -- строки не упорядочены, поэтому нельзя выбрать первую или последнюю строки...
            -- primary key: каждая строка однозначно определяется первичным ключом
                * ключ уникален
                * все строки разные (следствие уникальности ключа)
                * это относительная таблица -- по ней можно строит отношения (relation)
                * по ключу можно строить отношение -- relation
            -- внешний ключ: ключевое поле, связанное с primary key другой таблицы
                * позволяет извлекать связанные данные
        Транзакция
            -- объединение нескольких операции чтения и записи в одну логическую единицу
            -- выполняется либо вся полностью с фиксацией изменений,
               либо прерывается и откат к исходному состоянию
            -- значительно упрощает обработку ошибок
            -- ACID -- гарантии безопасности транзакции
                * Atomicy -- атомарность, неразрывность всех операций транзакции
                    > определяет рекацию СУБД на сбой;
                    > если транзакцию не удалось завершить, то транзакция прерывается и 
                      СУБД выполняет откат назад все уже выполненные операции записи,
                      в исходное до начала транзации состояние;
                    > без атомарности не было понятно, какие операции выполнены, а какие нет;
                    > исключает дублирование при попытке выполнения транзакции повторно;
                * Consistency -- согласованность и целостность, сохранение бизнес-правил состояния данных
                    > выполнение бизнес-правил как до начла транзации, так и после завершения транзакции,
                      например, если до начала не было отрицательного возраста человека, 
                      то и после завершения это бизнес-правило должно выполняться.
                    > данные переходят из одного корректного состояния в другое, так же корректное;
                    > техничское состояние данных (целостность внещнего ключа (ссылка не должна потеряться), 
                      ограничение уникальности)
                * Isolation -- изолированность
                    > паралельно выполняемые транзакции не видятж друг-друга и не могут помешать друг-другу;
                    > транзакция выполняется так, как будт-то она одна единственная в БД.
                * Durability -- сохраняемость, 
                    > надёжное место для сохранения данных;
                    > даже в случае сбоя данные сохраняются.
            -- Обеспечивает блокировку необходимых для транзакции данных до конца выполнения
                * данные могут быть недоступны до окончания транзакции;
                * при высоких нагрузках это может оказаться неприемлимым;
                * в случае больших данных, размещённых на нескольких серверах, -- это превращается в проблему
        Распределённые системы 
            -- CAP-теорема: программа может быть Хорошей, Быстрой и Дешёвой -- выбирайте любые 2-а св-ва!
                * Consistency -- согласованность 
                    > все клиенты должны прочитать одно и то же значение в ответ на один и тот же запрос,
                      даже если в это время производиться обновление данных;
                * Availibility -- доступность
                    > все клиенты всегда имеют возможность Читать и Записывать данные
                    > мы не можем ждать для этого завершения каких-либо операций
                * Partition tolerance -- устойчивость к разделению
                    > можно разделить между несколькими машинами;
                    > работает даже в случае отказа одного из сегментов.
            -- Состояния БД: ни одна работающая база данных не может находиться сразу в трёх состоянихя
                * C--A (согласованность и доступность), как правило один компьютер:
                    > MySQL, PostgreSQL
                * A--P (доступность и устойчивость к разделению):
                    > Cassandra, Riak
                * C--P (согласованность и распределённость): 
                    > Redis, MongoDB
                    > долго ждём операций обновления БД
            -- Современная структура: 
                * SQL-БД обеспечиваю основное хранение данных
                * NoSQL -- обеспечивают 
                    > специальные задачи
                    > сетевую связанность в распределённых нестабильных средах

    MySQL и КЛИЕНТЫ
        Особенности взаимодействия MySQL и клиентами
        
        mysql -u user_name -h 192.168.0.12 -P 3306 -p
            -u user_name -- пользователь
            -h IP -- хост
            -P number -- порт (напр. 3306)
            -p -- пароль
        
        Узнать порт, который назначен серверу (службе) mysql:
            * как команду mysql> SHOW VARIABLES LIKE 'port'
            * как команду Bash (под root): netstat -tlnp
        
        mysql-клиент, команды:
            \G -- вертикальный вывод: (после запроса) вывод не по строкам, а по столбцам
            \s, STATUS  -- статус сервера
                > версия
                > пользователь
                > порт
                > кодировки
            \!, SYSETEM -- выполнить системную команду, напрмер:
                    mysql> SYSTEM dir   -- это под Windows
                    mysql> SYSTEM ls ~  -- это под Linux
            \q, EXIT  -- выход
            \., SOURCE, маршрут-имяфайла.sql -- запуск файл SQL (без кавычек, даже если в полном имене есть пробелы)
        
        Параметры запуска клиента
            -- могут быть записаны в конфигурационный файл:
                >  my.cnf -- для Windows (в начале нет точки!)
                > .my.cnf -- для Linux (точка для скрытого файла в Unix объязательна)
            -- структура кон. файла:
                [mysql] -- раздел с именем клиента (сдесь "мysql"), кот. адресованы параметры
                user = user_name
                password = пароль
                [client] -- все клиенты дистрибутива MySQL, в том числе раздел и для утилиты mysqldump
                user = user_name
                password = пароль
                <EOF>
                * для ограничения доступа к этому файлу:
                    chmod 0600 ~/.my.cnf
        SQL-дамп БД
            mysqldump db_name > db_dump_filename.sql
                -- дамп базы данных db_name 
                -- запускается в терминале ОС, а не в клиенте mysql

            mysql db_name < db_dump_filename.sql
                -- развёртывание дампа в базу данных на сервере MySQL с использованием утилиты mysql
            mysql  SOURCE db_dump_filename.sql
            mysql> SOURCE db_dump_filename.sql
                -- так же развёртывание дампа, можно уже в самом интерпретаторе

            mysql db_name
                -- запуск клиента с выбором БД по умолчанию

        Архитектура MySQL:
            -- (запросы <->) ЯДРО <-> ДВИЖОК (InnoDB, MyISAM, Memory, Archive)

        Системная база данных: mysql
            -- только MySQL
            -- набор представлений, для унификации запросов:
                * information_schema -- информационная схема
                    > виртуальная, расположена тольков ОЗУ (нет физ-представления на HDD)
                        >> невозможно выбрать командой "USE"
                    > изменение таблиц этого представления недопускается...
                    > такую базу должны поддерживать все СУБД, поддерживающие стандарт SQL;
                    > SELECT * FROM information_schema.SCHEMATA
                        >> таблица "SCHEMATA" содержит списо баз данных...
                    > SELECT * FROM information_schema.TABLES WHERE table_schema = 'shop'\G

    ДОКУМЕНТАЦИЯ
        HELP, \h  -- помощь, команда клиента (";" не нужны)
            Прим: HELP DESCRIBE
        Сайт документации MySQL:
            mysql.com -> documentation -> MySQL Server -> + -> выбор версии
            https://dev.mysql.com/doc/
        


    УПРАВЛЕНИЕ БД
        -- каждая БД расположена в своём каталоге 
            * если каталог удалить, то база пропадёт из общего списка
            * если ОС чувствительна к регистру символов в имени каталога, 
              то имена в разных регистрах будут означать разные БД...
        -- текущее расположение всех баз:
            SHOW VARIABLES LIKE 'datadir'
            (C:\ProgramData\MySQL\MySQL Server 8.0\Data\)
        -- запрос или команда:
            * запрос передаётся на сервер только после обнаружения символа ";"
            * всегда завершается ";"
            * для длинных команд можно перейти на следующую строку вводом "Enter"

        CREATE DATABASE db_name;
            -- создание пустой базы данных
            -- если такая база уже есть, то приводит к ошибке
        CREATE DATABASE IF NOT EXISTS db_name;
            -- создание с условием
            -- не приводит к ошибке
        DROP DATABASE db_name;
            -- удаление базы db_name
            -- приводит к ошибе, если базы нет
        DROP DATABASE IF EXISTS db_name;
            -- удаление без ошибок
        USE db_name
        \u db_name
            -- выбор БД по умолчанию
            -- не является SQL-оператором, а командой клиента mysql, поэтому ";" можно не указывать
            !! неСтандартная команда, только MySQL
        SHOW TABLES;
            -- вывести список таблиц (если база данных выбрана)
            !- неСтандартная 
        SHOW TABLES FROM db_name;
            -- вывести список таблиц из БД "db_name"
        SELECT VERSION();
            -- вывести версию SQL-сервера
        SELECT mysql.User.User, mysql.User.Host,  FROM mysql.User;
            -- вывести поля User и Host таблицы User из (FROM) базы данных "mysql" и её таблицы "User";
            -- указаны полные, т. е. квалифицированные имена
        SELECT User FROM mysql.User;
            -- тоже, что и выше, но короче...
        SELECT User, Host FROM mysql.User;
            -- вывести поля User и Host из таблицы User базы mysql
        CREATE TABLE t_name (
            filed_name1 datatype_arguments,
            filed_name2 datatype_arguments 
            );
            -- создание таблицы "t_name" со списком полей
            -- возможна ошибка, если таблица существует
        CREATE TABLE IF NOT EXIST t_name (k INT);
            -- создание таблицы без ошибки
        DESCRIBE table_name ['fild_name'];  
            -- показать структуру таблицы
                * 'fild_name' -- только это поле
            -- каждая строка описывает одно поле в этой структуре
            -- LIKE-шаблоны:
                DESCRIBE table_name 'шаблон';
                    % -- заменяет любое количество символов
                    _ -- заменяет только 1-ин симовл
            !- нестандартный оператор (только MySQL).


ЯЗЫК ЗАПРОСОВ SQL
    Стандарт
        -- зародился в IBM и носил название SEQUEL (Structured English Query Language), но торговая марка была занята и название пришлось заменить на SQL 
        -- декларативный: описывает цель, а не инструкции
        -- в основе теория множества
        -- кросплатформенность
        -- наличие стандартов (1986, 1989, 1992, 1999, 2003, 2006 годах)
        -- Недостатки
            * слабоструктурированный
            * Старый (машинно ориентированный язык, а не человеко-ориентированный)
            * плохо взаимодействует с ООП-языками
                > стали появлятся ОРМ-системы, которые предоставляют объектно-ориентированный интерфейс к SQL
            * не универсальный -- нельзя создать программу в бинарном коде
            * множество диалектов (несмотря на наличие стандартов, идя впереди них)
        -- Компонетны:
            * комментарии
            * инструкции: DDL (описание) и DML (управление)
        -- Структура запроса
            SELECT id, name FROM users WHERE name='Иван'
            > выбрать (SELECT) поля id...
            > из (FROM) таблицы "users"
            > где (WHERE) значение поля "name" равно скаларному выражению "Иван"
        -- Экранирующие символы в запросах:
            SELECT 'Rubyst's world'; -- неправильно
            SELECT 'Rubyst\'s world'; -- правильно
            SELECT "Rubyst's world"; -- правильно, но двойные кавыки в PostgreSQL имеют специальное назначение
        -- Имена полей: любые символы, кроме "." и "\", "/" и ключевых слов
            * если имя содержит ключевое слове (INT, например), то его нужно взять в обратные ковычки:
                CREATE TABLE tbl (`create` INT); -- нет ошибки!

    Типы данных
        -- в поле определённого типа могут быть внесены только данные соотвествующего типа
        -- Типы данных:
            * Числовые
                > BIT -- bit value type
                  >> BIT(M), где M -- количество бит [от 1 до 64], по умолчанию -- 1.
                  >> BIT(1) может принимать значения 0 (FALSE), 1 (TRUE), NULL (и всё)
                  >> используется как логическое
                > целочисленные (https://dev.mysql.com/doc/refman/8.0/en/integer-types.html)
                  >> TINYINT   -- 1 байт:  0--256 
                  >> SMALLINT  -- 2 байта: 0--32767--65535
                  >> MEDIUMINT -- 3 байта: 0--8388607--16777215
                  >> INT       -- 4 байта: 0--2147483647--4294967295
                  >> BIGINT    -- 8 байта: 0--(2E+63 - 1)--(2E+64 - 1) // (2E+64 - 1 = 18446744073709551615)
                    Прим.: CREATE TABLE tbl (id INT(8) ZEROFILL) -- цифра 8 -- это формат отображения (но не задание байтов на число), т.е. 8-мь симовлов и пустые слева заполнить нулями
                > BOOL, BOOLEAN -- псевдонимы для TINYINT(1) с размером в 1 байт.
                  >> можно использовать как логическое, но размер большой...
                > вещественные (FLOAT (4 байта), DOUBLE (8 байт))
                > точные (DECIMAL) -- фактически строка, в которй записано число
                  >> самая медленная обработка
                  >> используется, чтобы избежать накопления ошибки при операции с вещественными цислами
                  >> финансовая сфера
                  >> Например DECIMAL(7,4) -- под всё число отводится 7 байт, а под друбную 4 байта
            * Строковые (фикрированные и переменного размера)
                > CHAR -- фиксированные
                > VARCHAR -- переменные с указанием максимального количества символов
                    >> для хранения используется специальная область в 65536 байт 
                    !> для всех таких полей в таблице этот объём переходить нельзя!!!
                > ТЕХТ (ИЛИ BLOB) -- объёмные бинарные данные или большие текстовые
                  >> TINYTEXT (256 байт)
                  >> TEXT (65536 байт)
                  >> MEDIUMTEXT (16Мб)
                  >> LONGTEXT (4 Гб)
                  >> хранятся в отдельной области памяти, чтобы не нарушать фиксированную длину записи
            * NULL (или NOT NULL) отсутствие данных (или присутсвие объязательно)
                > отсутствие данных
                > задаёт ограничение на столбец: разрешает или запрещает присваивать пустые значения
            * Календарные типы:
                > TIME -- время в течении суток (3 байта);
                > YEAR -- год (1 байт);
                > DATE -- дата с точностью до дня (3 байта);
                > DATETIME -- дата и время (8 байт);
                > TIMESTAMP -- то же, что и DATETIME, но:
                    >> размер поля в 4 байта, т. е. занимает в 2-а раза меньше места, чем DATETIME.
                    >> даты в диапазоне 1970--2038;
                Пример:
                    SELECT '2022-04-15 18:45:05'
                Примеры сложения и вычитания дат и времени:
                    SELECT '2022-04-15 18:45:05' - INTERVAL 1 DAY;
                    SELECT '2022-04-15 18:45:05' + INTERVAL 1 WEEK;
                    SELECT '2022-04-15 18:45:05' + INTERVAL 1 YEAR;
                    SELECT '2022-04-15 18:45:05' + INTERVAL '1-1' YEAR_MONTH; -- кавычки объязательно!!!
                    SELECT '2022-04-15 18:45:05' + INTERVAL '1+1' YEAR_MONTH + INTERVAL 5 DAY;

            * Коллекции (множества или JSON-документы) или коллекционные типы:
                > ENUM -- елемент множества 
                    >> поле может принимать только одно значение из списка возможных значений;
                    >> список значений типа "строка" (через запятую): 'first','second','third'
                    >> внутреннее представление -- цифровое
                    Пример: first
                > SET -- несколько элементов множества (или весь список)
                    >> поле принимает набор значений из возможного списка;
                    Пример: first,second
                > JSON -- готовый объект языка JavaScript
                    Пример:
                        ALTER TABLE tbl ADD collection_json JSON;
                        DESCRIBE tbl;
                        INSERT INTO tbl VALUES (1, '{"first": "Hellow", "second": "TelePusik"}');
                        SELECT * FRON tbl;
                        SELECT collection_json->>"$.first" FROM tbl;
                        SELECT collection_json->>"$.second" FROM tbl;
                        +------------------------------+
                        | collection_json->>"$.second" |
                        +------------------------------+
                        | NULL                         |
                        | TelePusik                    |
                        +------------------------------+
                        2 rows in set (0.00 sec)
        -- Атрибуты:
            * NULL или NOT NULL
                > задаёт ограничение на столбец: 
                  разрешает или запрещает присваивать пустые значения
            * DEFAULT 
                > значение по умолчанию, если при создании записи значение полю не было присвоено
            * UNSIGNED
                > только для цифровых
                > только положительные (2 в 32 степени = 4'294'967'295)
                > положительные и отрицательные (2 в 31 степени = 2'147'683'647)

DDL (Data Definition Language)
    Таблица
        Обычная
            CREATE TABLE table_name (
                id BIGINT UNSIGNED NOT NULL,
                first_name VARCHAR(255),
                birthday DATE
            );
        С обновляемым полем дата-время!
            CREATE TABLE table_name (
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
            );
        Временная (https://dev.mysql.com/doc/refman/8.0/en/create-temporary-table.html)
            CREATE TEMPORARY TABLE t_tmp LIKE user;
            -- создать временную таблицу t_tmp по структуре как user
               без внесения данных
            -- существует только в пределах текущего сеанса и автоматически удаляется при завершении сеанса
            -- одновременно в разных сеансах можно создать временную таблицу с одним и тем же именем безконфликтно!
            -- удаление базы данных не приводит к удалению временной таблицы.
            -- Временные таблицы хранятья в файле ibtmp1
            -- ВНИМАНИЕ! Не будет поддерживаться в дальнейшем, начиная с MySQL 8.0.13... но в 8.0.23 поддерживается...

        Вычисляемое поле -- "AS"
            CREATE TABLE table_name (
                x INT,
                y INT,
                summ AS (x + y) 
            );
            -- чтобы вычисляемое поле хранилось в таблице 
               необходимо добавить ключевое слово STORED:
                summ AS (x + y) STORED

        Вычисляемое поле с датой
            CREATE TABLE table_name (
                id BIGINT UNSIGNED NOT NULL,
                first_name VARCHAR(255),
                birthday DATE,
                age AS TIMESTAMPDIFF(YEAR, birthday, CURRENT_DATE())
            );
        Проверка (ограничение), CHECK:
            CREATE TABLE table_name (
                x INT,
                y INT,
                summ AS (x + y) CHECK (summ > 1)
            );
        -- или отдельно с собственным именем ограничения
            CREATE TABLE table_name (
                x INT,
                y INT,
                summ AS (x + y),
                CONSTRAINT summ_check_1 CHECK (summ > 1)
            );

    Индексы
        -- их использование ускоряет выполнение запросов
            > используются для ОПТИМИЗАЦИИ базы
        -- Имеют собственные имена (чтобы их можно было удобно различать)
        -- Типы:
            > BTREE -- бинарное дерево; ?????????????? НЕ ПОНИМАЮ ЭТОГО
                >> значения храняться по порядку
                >> все листовые страницы дерева храняться на одинаковом расстоянии от корня, что повышает скорость
                >> полезен для поиска по диапазону
                Пример:
                    CREATE INDEX index_of_catalog_id USING BTREE ON products(catalog_id);
            > HASH -- хэш-таблица.
                >> строится на основе хзш-таблицы
                >> полезен только для точного поиска с указанием всех столбцов индекса...
                Пример:
                    CREATE INDEX index_of_catalog_id USING BTREE ON products(catalog_id);
        -- Виды
            > обычный (не уникальный)
                >> при обращении может выдать больше одного значения (высокая селективность)
                INDEX или KEY
                Пример:
                    CREATE TABLE products (
                        id INT UNSIGNED PRIMARY KEY,
                        catalog_id INT UNSIGNED,
                        name VARCHAR(255) COMMENT 'Название',
                        KEY index_of_catalog_id(catalog_id)
                    );
            > уникальный (UNIQUE)
                >> селективность = 1;
                >> значения в них не должны повторяться;
                >> может быть несколько.
                Прим.
                    CREATE TABLE catalogs (
                        id SERIAL PRIMARY KEY,
                        name VARCHAR(255),
                        UNIQUE unique_name(name(10))
                    );
            > уникальный первичный ключ (PRIMARY KEY)
                >> уникальный индекс
                >> предназначен только для первичного ключа
                >> может быть только один
                Пример:
                    CREATE TABLE catalogs (
                        id INT UNSIGNED NOT NULL UNIQUE AUTO_INCREMENT PRIMARY KEY,
                        name VARCHAR(255) COMMENT 'Название'
                    ) COMMENT = 'Разделы каталога';
                или
                    CREATE TABLE catalogs (
                        id INT UNSIGNED NOT NULL UNIQUE AUTO_INCREMENT,
                        name VARCHAR(255),
                        PRIMARY KEY (id)
                    );
                или
                    CREATE TABLE catalogs (
                        id INT UNSIGNED NOT NULL UNIQUE AUTO_INCREMENT,
                        name VARCHAR(255),
                        PRIMARY KEY (id, name(10))  /* индекс сразу по 2-м столбцам и, при этом, */
                    );                              /* для name только первые 10 символов */
                или
                    SERIAL = BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE
                    -- это стандартная предпочтительная форма, 
                       но в соединении с Primary key мы получаем два ключа вместе UNIQUE,
                       это затрудняет обработку или может быть недопустимо с таблицами типа Archive (ENGINE=Archive)
                    CREATE TABLE catalogs (
                        id SERIAL PRIMARY KEY,
                        name VARCHAR(255)
                    );
                    CREATE TABLE catalogs (
                        id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
                        name VARCHAR(255),
                    ) ENGINE = Archive;
                UNIQUE -- создаёт отдельный индекс
                PRIMARY KEY -- создаёт отдельный индекс
                >> случше их вместе не сочетать, а то получиться сразу два индекса
            > полнотекстовый
                >> для столбоцов типа TEXT
                >> позволяет производить полнотекстовый поиск
                >> здесь не рассматривается, так как на практике эта задача
                   решается специальными СУБД (ElasticSearch,...)

        -- Операции с индексами
            > Добавление индекса.
                >> Может быть создан (добавлен) в уже существующей таблице (products)
                Пример:
                    CREATE INDEX index_of_catalog_id ON products (catalog_id);
            > Удаление
                Прим.:
                    DROP INDEX index_of_catalog_id ON products;

    СВЯЗИ: Внешние ключи
        1--1 один к одному (разделённая таблица)
            -- примером может служить таблицы users и user_preferenses, 
               где каждой записи одной соответствует строго одна запись в другой таблицы
            -- такие таблицы можно объединить в одну
            Пример: связь 1--1
                CREATE TABLE users ( 
                    id SEREAL PRIMARY KEY,
                    name VARCHAR(255)
                );
                CREATE TABLE profiles (
                    user_id BIGINT UNSIGNED NOT NULL,
                    birthday DATE,
                    CONSTRAINT fk_profiles_user_id FOREIGN KEY (user_id) REFERENCES user.id
                ); /*-- или без именования связи: FOREIGN KEY (user_id) REFERENCES user.id */
            Пример: связь 1--1
                ALTER TABLE profiles ADD CONSTRAINT fk_profiles_user_id FOREIGN KEY (user_id) REFERENCES users(id);
                -- добавление внешнего ключа отдельно от описания таблицы (имя объязательно)
                ALTER TABLE profiles DROP CONSTRAINT fk_profiles_user_id;
                -- удаление внешнего ключа из описанной таблицы по имени внешнего ограничения
        1--X (один ко многим)
            -- таблица объектов (справочкик) + 
               + связанная таблица использоания объектов, ссылающаяся на справочник
        X--X (многие ко многим)
            -- два справочника (виды_объектов + склады) + 
               + таблица связи (каждый вид объекта может одновременно 
                 находиться на нескольких складах)

DML (Data Manipulation Language)

    CRUD-операции с данными (Create=INSERT + Read=SELECT + Update + Delete)
        -- Базовые операции
            > INSERT
                EN: https://dev.mysql.com/doc/refman/8.0/en/insert.html
                RU: http://www.mysql.ru/docs/man/INSERT.html)
                >> добавление данных в существующую таблицу;
                    Пример: по одной записи
                        INSERT INTO catalogs VALUES (NULL, 'Процессоры');
                        INSERT INTO catalogs VALUES (0, 'Системные платы');
                    Пример: пакетом
                        INSERT INTO catalogs VALUES
                            (DEFAULT, 'Процессоры'),
                            (DEFAULT, 'Системные платы');
                        Примечание: 
                            NULL, 0, DEFAULT -- одно и то же для поля с инкрементом
                >> вставка записей с указанием полей
                    Пример: вставка только в указанные поля
                        INSERT INTO table_name (field_2, note) VALUE ('Процессоры', 'описание');
                >> используя конструктор строк, то есть синтаксис VALUES ROW()
                    Прим.: исп. конструктор строк ROW()
                        INSERT INTO tbl_name (a,b,c)
                            VALUES ROW(1,2,3), ROW(4,5,6), ROW(7,8,9);
                >> INGOR -- используется для игнорирования ошибок ключа (пропускаем)
                    Пример: игнорирование ошбки ключа
                        INSERT IGNORE INTO catalogs VALUES (NULL, 'Процессоры');
                        * вставка без генерации ошибки при дублировании в уникальном поле
                        * просто не выполниться эта вставка
                >> не игнорируем ошибки ключа:
                    INSERT ... UPDATE 
                        * обновление записи с конфликтом
                    REPLACE
                        * предварительное удаление записи с конфликтом
            > SELECT
                EN: https://dev.mysql.com/doc/refman/8.0/en/select.html
                RU: http://www.mysql.ru/docs/man/SELECT.html
                    http://www.mysql.ru/docs/man/Selecting_rows.html
                >> извлечение столбцов
                    Прим.:
                        SELECT name, id FROM catalogs;
                    или все столбцы без их указания
                        SELECT * FROM catalogs;
                    и сортировка
                        SELECT * FROM users ORDER BY lastname;
                    в обратном порядке
                        SELECT * FROM users ORDER BY lastname DESC;
                    без повторений 
                        SELECT DISTINCT lastname FROM users ORDER BY lastname;
                >> VALUES ROW(v1-1, v1-2), ROW(v2-1, v2-2);
                    en: https://dev.mysql.com/doc/refman/8.0/en/values.html
                    -- конструктор табличных значений
                    -- возвращает набор из одной или нескольких срок в виде таблицы
                    Пример: 
                        VALUES ROW(1), ROW(2);
                        -> column_0
                        -> 1
                        -> 2
                        -- возвращено две строки 1-ого столбца с именем column_0
                >> VALUES и SELECT
                    SELECT name_1, name_2 FROM (VALUES ROW('v1-1', 'v1-2'), ROW('v2-1', 'v2-2')) AS x(name_1, name_2);
                или 
                    SELECT * FROM (VALUES ROW('v1-1', 'v1-2'), ROW('v2-1', 'v2-2')) AS x;
                    -- возвращаемые конструктором таблицных значений данные можно именовать и использовать в SELECT
                    -- обязательный псевдоним таблицы 'x' , используемый для задания имён столбцов
                    для задания имён столбцов (name_1 и name_2),
                    которые далее используются для вывода (или вычислений) в операторе SELECT
                    Прим.: вывести разницу между суммой первого столбца и средним арифметическим второго
                        SELECT SUM(name_1) - AVG(name_2) FROM (VALUES ROW(1, 10), ROW(2, 20)) X(name_1, name_2) \G;
                        -> -12.0000
            > VALUES и INSERT
                -- см. Insert и Update

            > UPDATE
                EN: https://dev.mysql.com/doc/refman/8.0/en/update.html
                RU: http://www.mysql.ru/docs/man/UPDATE.html
                >> позволяет менять значения полей в уже существующих записях
                Прим.:
                    UPDATE catalogs SET name = 'Процессоры (Intel)'
                        WHERE name = 'Процессоры';
                    UPDATE users SET 
                        fullname = (SELECT fullname FROM profiles WHERE user_id = users.id);
                    -- переносим поле из связанных по ключу 1 к 1 таблиц.
            > DELETE
                EN: https://dev.mysql.com/doc/refman/8.0/en/delete.html
                RU: http://www.mysql.ru/docs/man/DELETE.html
                >> удаление по записи (в соответствии с условиями)
                    *** не обнуляется авто-инкремент
                    Примеры.
                    все (но по одной и долго)
                        DELETE FROM catalogs;
                    или не все
                        DELETE FROM catalogs LIMIT 2; /* удаляем какие-то 2-е записи */
                    или по условию
                        DELETE FROM catalogs WHERE id > 1 LIMIT 1;
            > TRANCATE
                EN: https://dev.mysql.com/doc/refman/8.0/en/truncate-table.html
                RU: http://www.mysql.ru/docs/man/TRUNCATE.html
                >> очистка таблицы TRANCATE
                    * без условий
                    * быстро
                    * обнуляется счётчик AUTO_INCREMENT
                    Пример:
                        TRANCATE catalogs;
            > INSERT и SELECT
                >> извлечение с одновременным добавление в другую таблицу
                    INSERT INTO catalog_1 
                        SELECT * FROM catalog;
                >> для более сложных конструкций лучше использовать вариант с подзапросом и псевдонимом
                    INSERT INTO sample.users (id, name) 
                        SELECT * FROM (SELECT id, name FROM example.users WHERE id = 1) AS new_values;
                    ВНИМАНИЕ! 
                        Далее можно продолжить этот запрос используя ON DUPLICATE KEY UPDATE
                        используя псевдоним для присвоения новых значений...
            > INSERT и UPDATE и функция VALUES(col_name)
                >> пытаемся добавить запись, а если не получатеся (она уже сеть), 
                   то обновяем!
                    INSERT ... ON DUPLICATE KEY UPDATE Statement
                >> в операции обновления необходимо запросить данные, которые могли бы быть вставлены, 
                   если бы не было ошибки ключа. 
                   Для такого случая используется функция VALUE(), в которой можно сослаться на такое значение
                   (исп. только в этом случае)
                   https://dev.mysql.com/doc/refman/8.0/en/miscellaneous-functions.html#function_values
                   https://dev.mysql.com/doc/refman/8.0/en/miscellaneous-functions.html#function_values
                Пример: при проблеме с ключём -- тогда обновляем
                    INSERT INTO users (listid,email,age,name) VALUES 
                        (3,'vit9@gmail.com',26,"Витя"),
                        (3,'kat9@gmail.com',32,"Катя"),
                        (3,'masha@gmail.com',29,"Маша"),
                        (2,'vit9@gmail.com',25,"Витя"),
                    ON DUPLICATE KEY UPDATE                 -- запись уже есть с таким ключём, 
                        listid=VALUES(listid),              -- поэтому обновляем даже все поля, 
                        email=VALUES(email),                -- в том числе и ключевое (на то же значение)...
                        age=VALUES(age),                    -- Но, наверное, можно искючить обновление ключевого поля
                        name=VALUES(name);                  -- в этой конструкции
                    ВНИМАНИЕ! Функция VALUES() не будет поддерживаться в дальнейшем. 
                              Используйте псевдонимы.
                Пример с псевдонимом строки (вместо функции values(), см. прим. выше): 
                    INSERT INTO users (listid,email,age,name) VALUES (1, 123@mail.ru, 18, Ivan) AS new(a, b, c, d)
                    ON DUPLICATE KEY UPDATE 
                        listid = new.a,
                        email = new.b,
                        age = new.c,
                        name = new.d;

            > INSERT и SELECT и UPDATE
                Пример (с псевдонимом):
                    INSERT INTO sample.users (id, `name`, birthday_at, created_at, updated_at)
                        SELECT * FROM ( 
                            SELECT id, `name`, birthday_at, created_at, updated_at FROM shop.users WHERE id = 1
                            ) AS shop_new
                    ON DUPLICATE KEY UPDATE 
                        id          = shop_new.id, --  на случай всё же удаления (тогда id надо восстановить)
                        `name`      = shop_new.`name`,
                        birthday_at = shop_new.birthday_at,
                        created_at  = shop_new.created_at,
                        updated_at  = shop_new.updated_at ;

            > REPLACE INTO test VALUES(1,...) as NEW
                >> если запись есть с таким ключём (в нашем сл. -- 1), 
                   то вначале удаляет её (на практике не подтверждается),
                   а потом вставляет новую командой INSERT 
                   Прим.: работает как обновление в случае нарушения ключа (подтверждено опытом)
                >> если записи нет с таким ключём, то сразу вставляет новую, 
                   то есть работает как INSERT

            DROP TABLE
                -- удаление таблицы
                    Прим.
                        DROP TABLE IF EXISTS tbl;

Генерация данных
    -- Сервисы для генерации данных:
        http://filldb.info/
        http://www.generatedata.com/
        https://sourceforge.net/p/benerator/wiki/Home/
        http://www.dominicgiles.com/datagenerator.html

Изменения таблицы
    ALTER TABLE profiles ADD CONSTRAINT fk_profiles_user_id FOREIGN KEY (user_id) REFERENCES user(id);
        -- ограничение (constraint) целостности, DLL-команда
        -- сязать 1--1 таблицы "profiles(user_id)" и "users(id)" по указанному в скобках полу и главным является user(id)

    ALTER TABLE profiles ADD COLUMN birthday DATETIME;
        -- добавить колонку
        Пример (сразу несколько колонок, проверено):
            ALTER TABLE tb1
                ADD COLUMN `birthday_at` date DEFAULT NULL COMMENT 'Дата рождения',
                ADD COLUMN `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
                ADD COLUMN `updated_at` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
            ;
    ALTER TABLE profiles RENAME COLUMN birthday TO date_of_birth;
        -- переименовать колонку

    ALTER TABLE profiles DROP COLUMN date_of_birth;
        -- удалить колонку

    ALTER TABLE profiles MODIFY field_name CHAR(50);
    ALTER TABLE messages MODIFY from_user_id BIGINT UNSIGNED NOT NULL;
        -- изменяем тип поля
            Пример (несколько колонок за раз): 
                ALTER TABLE messages 
                    MODIFY from_user_id BIGINT UNSIGNED NOT NULL,
                    MODIFY col1 VARCHAR(255),
                    MODIFY col2 INT DEFAULT 0;
        -- Может привести к потере данных (усечение строки и т. п.)
            > для предотвращения потери можно ключить строгий режим SQL
              https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html
              SET GLOBAL sql_mode = 'режимы';
              SET SESSION sql_mode = 'режимы';
                >> сложно, не разобрался...
            > не рекомендуется менять режим после создания секционированных (partition) таблиц
              https://dev.mysql.com/doc/refman/8.0/en/partitioning-limitations.html
           
    ALTER TABLE friend_requests ADD CHECK (id_1 <> id_2);
        -- добавляем проверку: поля id_1 и id_2 не могут быть равны

    ALTER TABLE users AUTO_INCREMENT=21;
        -- установить стартовую позицию автосчётчика для следующей новой строки в 21.
        -- может потребоваться, если таблица обнулялась и...

    ALTER TABLE profiles ADD CONSTRAINT fk_profiles_user_id FOREIGN KEY (user_id) REFERENCES users(id);
        -- добавить связь

    ALTER TABLE profiles DROP CONSTRAINT fk_profiles_user_id;
        -- удалить связь


ОПЕРАТОРЫ, ВЫБОРКИ, ФУНКЦИИ
    Арифметические операторы
        + -- сложение
            SELECT 2 + 5 ;
            или
                SELECT '2' + '5' ;
                -- строки будут преобразованы в числа автоматически...    
            или
                SELECT 'ыва' + 'sldkf' ;
                -- если строка не может быть преобразована в число, то она принимается равной 0 (нулю).
        - -- вычитание (бинарный оператор)
                SELECT 2 - 5 ;
          -- изменение знака операнда (присвоение отрицательного значения) 
             (унарный оператор)
                SELECT -5 ;
        * -- умножение
                SELECT 2 * 5 ;
            -- если выходим за диапазон BIGIND то возвращается ОШИБКА!            
        / -- деление
            -- обычно
                SELECT 5 / 2 ;
            -- на ноль возвращает NULL (а НЕ ОШИБКУ)
                SELECT 5 / 0 ; 
                > NULL
        %, MOD, MOD() -- остаток от деления
                SELECT 5 % 2 ;
            или 
                SELECT 5 MOD 2 ;
            или с использованием функции
                SELECT MOD(5, 2) ;
        DIV -- целочисленное деление
                SELECT 5 DIV 2 ;
        INTERVAL -- команда 
            -- позволяет прибавлять (вычитать) интервал из даты в указанных единицах
            -- список единиц измерения:
                SECOND	секунды
                MINUTE	минуты
                HOUR	часы
                DAY	дни
                MONTH	месяцы
                YEAR	года
                MINUTE_SECOND	"минуты:секунды"
                HOUR_MINUTE	"часы:минуты"
                DAY_HOUR	"дни часы"
                YEAR_MONTH	"года-месяцы"
                HOUR_SECOND	"часы:минуты:секунды"
                DAY_MINUTE	"дни часы:минуты"
                DAY_SECOND	"дни часы:минуты:секунды"            
            Пример:
                SELECT '2022-03-16' - INTERVAL 1 YEAR;  -- вычесть 1 год..ы
                -> '2021-03-16'
                SELECT '2022-04-15 18:45:05' + INTERVAL 1 YEAR;
                SELECT '2022-04-15 18:45:05' + INTERVAL '1-1' YEAR_MONTH; -- кавычки объязательно!!!
                SELECT '2022-04-15 18:45:05' + INTERVAL '1+1' YEAR_MONTH + INTERVAL 5 DAY;
        Внимание: 
            все операции с NULL результатом имеют NULL

    Операторы сравнения 
        -- возвращается 0 или 1
        -- возвр. NULL, при обычном (небезопасном) сравнивании с NULL
        TRUE, FALSE -- логические константы == псевдонимы 1 (TINYINT) и 0 (TINYINT)
        NOT, ! -- логическое отрицание
            SELECT NOT 1 > 2 ;
            SELECT ! 1 > 2 ;
        > -- больше
            SELECT 1 > 2 ;
            mysql> 0
        >= -- больше или равно: порядок знаков важен! (чтобы не перепутать с присваиванием, наверное)
            SELECT 1 >= 1 ;
            mysql> 1
        < -- меньше
        <= -- меньше или равно
        = -- равно
            SELECT 1 = NULL ;
            mysql> NULL
        !=, <> -- не равно
        <=> -- безопасное равно (на случай, если попадётся NULL)
            SELECT NULL <=> NULL ;
            mysql> 1
        IS -- классическое безопасное сравнение с NULL (только)
            SELECT 1 IS NOT NULL ;
            mysql> 1
            SELECT 1 IS TRUE, 0 IS FALSE, NULL IS UNKNOWN ;
            mysql> 1, 1, 1

    Логические операторы
        OR
        AND 
            -- имеет приоритет перед OR
            -- () -- скобки для изменения приоритета

    Выборки, ключевые слова
        WHERE: условие для выборки
            SELECT * FROM t WHERE id >= 3 AND id <= 7 ;
        IN(): 
            -- для WHERE
            -- в списке
                Пример:
                    SELECT * FROM t WHERE id IN(3, 4, 5, 6, 7) ;
            -- NULL в списке вернёт NULL на все сравнения!
                Пример:
                    SELECT * FROM t WHERE id IN(3, 4, 5, 6, 7, NULL) ; 
                    >> вернёт в том числе и NULL (и все строки будет пропущены, так как NULL не равен NULL)
            -- ВНИМАНИЕ: отбрасывает повторения!
                Пример: одно и то же
                    SELECT * FROM t WHERE id IN(1, 2, 3) ;
                   и...
                    SELECT * FROM t WHERE id IN(1, 2, 3, 1, 1, 1) ;
    
        BETWEEN--AND: в диапазоне:
            SELECT * FROM t WHERE id BETWEEN 3 AND 7 ;
            SELECT * FROM t WHERE id NOT BETWEEN 3 AND 7 ;
        LIKE: выборка похожих элементов (строк)
            SELECT 'программа' LIKE 'про%'
                где % -- любое количество символов
                или _ -- только 1-ин символ
        RLIKE (REGEXT, синоним) -- регулярные выражения для поиска
            -- удобные
            -- медленно выполняются
            -- виды:
                ^ -- начало строки;
                $ -- символ конца строки;
                | -- альтернатива, логическое ИЛИ;
            -- классы (для задания используются квадратные скобки)
                [abc] -- класс символов, список  (выбирается по одному и сравнивается);
                Пример: 
                    [a-w] -- список, заданный диапазоном;
                    [а-яё] -- список всех символов кирилицы, 
                              при этом "ё" не входит в этот диапазон и задаётся отдельно (особенность кодировки);
                    [0-9] -- все цифры
                [[:digit:]] -- класс любых цифр, соответствует одному цифровому символу
                [[:alpha:]] -- класс любых букв
            -- квантификаторы, указываются сразу после квадратных скобок класса
                ? -- символ входит 0 или 1 раз в строку;
                * -- символ входит 0 или более раз (любое количество);
                + -- символ входит 1 или более раз;
                {n} -- точное указание n-количества символов
            Пример:
                '[0-9]*' -- любое количество цифр, в том числе и нисколько
                '[0-9]+' -- количество от 1-ой и более любых цифр
                '\\.' -- знак десятичной точки (экранирование выполняется 2-я слешами)
                '[.|,]{1} -- тоже самое, но с запятой
                '[0-9]{2}' -- только две цифры (не больше и не меньше)
                '[0-9]+[.]{1}[0-9]{2}' -- десятичное числе, напр. 123.56
                SELECT '12345.67' RLIKE '[0-9]+[.]{1}[0-9]{2}' ; -- находим цену
            Пример:
                SELECT birthday_EN FROM users WHERE birthday_EN RLIKE 'may|august';
                -- где birthday_EN является строкой даты в каком-то нестандартном формате
                   с указание месяцев словами по английски и мы хотим найти даты с 'may' и 'august'
            Примеры:
            -- найти вхождение последовательности 'грам' в словах 'программа' и 'граммпластинка'
                SELECT 'программа' RLIKE 'грам', 'граммпластинка' RLIKE 'грам' \G
                * везде найдено, результат ИСТИНА
            -- найти подстроку в слове с начала строки ("крышечка")
                SELECT 'граммофон с пластинками' RLIKE '^грам' ;
                * найдено, результат ИСТИНА
            -- найти подстроку в слове с конца строки ("доллар")
                SELECT 'граммофон и пластинка' RLIKE 'пластинк$' ;
                * не найдено, результат ЛОЖЬ
            -- найти подстроку как самостоятельную строку ("$" и "^")
                SELECT 'граммофон и пластинка' RLIKE '^пластинка$' ;
                * не найдено, результат ЛОЖЬ
                SELECT 'пластинка' RLIKE '^пластинка$' ;
                * найдено, результат ИСТИНА
            -- найти символы из списка (a или b или c):
                SELECT 'a' RLIKE '[abc]' ; 
                * найдено, результат ИСТИНА
                SELECT 'w' RLIKE '[abc]' OR '[w]' ; 
                * не найдём -- неверная конструкция
                SELECT 'w' RLIKE '[abcw]'; 
                * найдём!
            

    Сортировка и выборка
        https://www.simplecoding.org/sortirovka-v-mysql-neskolko-redko-ispolzuemyx-vozmozhnostej.html
        -- сортировка:
            ORDER BY поля через запятую [DESC] 
            Прим.:
                SELECT * FROM users ORDER BY firstname ASC, lastname; -- сортировка
                SELECT * FROM users ORDER BY firstname DESK, lastname DESK; -- с-ка в обратном порядке
        -- сортировка в заданном порядке (например IN(...)):
            SELECT * FROM users WHERE id IN(5, 1, 2) ORDER BY FIELD(id, 5, 1, 2)
        -- выборка с ограничением количества строк или по страницам:
            LIMIT n; где n -- количество выводимых строк, 
                     всегда последнее
                Прим.:
                    SELECT * FROM users ORDER BY firstname LIMIT 2; -- вывод только 2-х записей
            LIMIT p, n; где р -- позиция с которой начинается выбрка следующей страницы
                Прим.:
                    SELECT * FROM users ORDER BY firstname LIMIT 2, 2; -- вывод только 2-х записей 2-ой страницы
                    SELECT * FROM users ORDER BY firstname LIMIT 4, 2; -- вывод только 2-х записей 3-ой страницы
            LIMIT n OFFSET p; аналог предыдущего
        -- выборка только уникальных значений:
            DISTINCT -- указывается перед именем столбца
                Прим.:
                    SELECT DISTINCT firstname FROM users;
                    * вывод только уникальных имён
                    SELECT DISTINCT firstname, lastname FROM users;
                    * уникальными являются сумма имени и фамилии,
                      а не по отдельности
        -- выборка всех значений:
            ALL -- выводим все значения (в т.ч. и повторяющихся), 
                   по умолчанию
                Прим.:
                    SELECT ALL firstname FROM users;
                   или (тоже самое)
                    SELECT firstname FROM users;
        -- сортировка по указанному списку:
            > исп. функцию FIELD(), см. описание в разделе строковых функций
            SELECT * FROM articles ORDER BY FIELD(a_season, "весна","лето","осень","зима")

        -- GROUP BY
            ...см. далее...

    Функции (https://dev.mysql.com/doc/refman/5.7/en/functions.html)
        Время
            time -- тип данных:
                > тип строковый, в формате:
                    >> 'hh:mm:ss' формат (or 'hhh:mm:ss' format for large hours values)
                > диапазон: 
                    >> от '-838:59:59' до '838:59:59'
                    >> от '-838:59:59.000000' to '838:59:59.000000'
            date -- тип данных:
                > 
            datetime -- тип данных:
                > ... 

            NOW(fsp) -- текущее время и дата
                https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_now
                -- возвращает постоянное время от начала выполнения запроса
                -- вычисляются одни раз для всех вызовов в рамках одного запроса
                    > время одинаков для всех вызовов в одном запросе
                    > имеет детерминированный (предсказуемый) характер
                    > может использоваться для транзакций (не проверено)
                    > может использоваться для индексов
                -- тип зависит от контекста использования:
                    > строка 'YYYY-MM-DD hh:mm:ss' -- строка в строковом контексте
                        Прим.: 
                            SELECT NOW();
                            -> '2022-05-19 15:22:21'
                    > число (тип???), в числовом контексте
                        Прим.:
                            SELECT NOW() + 0;
                            -> 20220519152210
                -- fsp точность от 1 до 6 знаков секунд, если указана
                Синонимы:
                    CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP
                    LOCALTIME(), LOCALTIME
                    LOCALTIMESTAMP(), LOCALTIMESTAMP
                Прим., задание времени созданий и обновлений полей таблицы:
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
                Прим.:
                    SELECT NOW(), SLEEP(2), NOW();
                    -> 2006-04-12 13:47:36 |        0 | 2006-04-12 13:47:36 
                    -- время НЕ изменилось

            SYSDATE(fsp) -- время и дата для текущего запроса
                -- то же самое, что и NOW(), но время в запросе разное!
                -- не детерминирован
                    > не может использоваться в транзакциях
                    >  индексы не могут использоваться для вычисления выражений, которые ссылаются на него
                Прим.:
                    SELECT SYSDATE(), SLEEP(2), SYSDATE();
                    -> 2022-05-19 15:33:21 |        0 | 2022-05-19 15:33:23
                    -- время ИЗМЕНИЛОСЬ
                -- сделать псевдонимом NOW(): параметр --sysdate-is-now
                    > работает как для источника, так и для реплики

            DATE(строка) -- дата из строки
                Прим.: такущая дата как строка (формат не знаем)
                    SELECT DATE(NOW()) ;

            DAYOFYEAR() -- тип int
                -- день в году, то есть номер дня от начала года

            TIME(expr) строковый тип
                -- время из строки
                -- expr: тип time или тип date (формат) -- см. ниже
                -- тип: 
                -- тип возврата зависит от контекста использования:
                    > число, в арифметическом выражении
                    > строка
                    Прим.: 
                        SELECT TIME('2003-12-31 01:02:03') ;
                        -> '01:02:03'
                        SELECT TIME(NOW()) ;
                        -> '15:50:30'
                    Пример ошибки:
                        SELECT TIME(NOW()+59)) ; -- ОСТОРОЖНО С ВЫЧИСЛЕНИЯМИ
                        -> NULL

            CURDATE(), тип строковый или целый
                -- возвращает текущий день в формате 
                   строки 'YYYY-MM-DD' или числа YYYYMMDD,
                   в зависимости от контекста использования
                Пример:
                    SELECT CURDATE();
                        -> '2008-06-13'
                    SELECT CURDATE() + 0;
                        -> 20080613

            CURTIME([fsp]) тип строковый или числовой
                -- возвращает текущее время в формате 'hh:mm:ss' или hhmmss
                   в зависимости от контекста
                Пример:
                    SELECT CURTIME();
                    -> '23:50:26'
                    SELECT CURTIME() + 0;
                    -> 235026.000000

            TIMEDIFF(exp1, exp2) типа time или datetime
                -- возвращает разницу во времени (exp1 - exp2) 
                -- возвращает тип time или datetime
                -- тип аргументов: time или date
                    > аргументы должны быть одного типа 
                Примеры с ошибками:
                    SELECT TIMEDIFF((NOW()+59), (NOW()+0));
                    -> NULL
                    SELECT TIMEDIFF((NOW()+100), NOW());
                    -> 00:01:00
                    ВНИМАНИЕ! Секунды десятичные в таком использовании...

            DATEDIFF(exp1, exp2) 
                -- разница (exp1 - exp2) в днях 
                    Пример:
                        SELECT DATEDIFF('2007-12-31 23:59:59','2007-12-30');
                        -> 1
                        SELECT DATEDIFF('2012-05-01', '2010-05-02');
                        -> 730

            TIMESTAMP(expr) -- возврат тип date или datetime
                -- expt: date или datetime
                Пример:
                    SELECT TIMESTAMP('2003-12-31');
                    -> '2003-12-31 00:00:00'

            TIMESTAMP(expr1, expr2) -- сложение даты и времени
                -- возврат: тип date или datetime
                -- складывает: expr1 + expr2 (в таком порядке)
                Пример:
                    SELECT TIMESTAMP('2003-12-31 12:00:00','12:00:00');
                    -> '2004-01-01 00:00:00'
                    
            TIMESTAMPADD(unit, interval, datetime_expr) -- типа date
                -- приращение даты на целочисленный interval, 
                   в указанных единицах измерения unit
                -- Временные интервалы (unit):
                   (https://dev.mysql.com/doc/refman/8.0/en/expressions.html#temporal-intervals)
                    > MINUTE
                    > HOUR
                    > DAY
                    > WEEK
                    > YEAR
                    > MONTH
                    > QUARTER
                    > DAY_SECOND -- 'DAYS HOURS:MINUTES:SECONDS'
                    > DAY_MINUTE -- 'DAYS HOURS:MINUTES'
                    > DAY_HOUR -- 'DAYS HOURS'
                    > YEAR_MONTH -- 'YEARS-MONTHS'
                Пример:
                    SELECT TIMESTAMPADD(HOUR, 1, '2022-05-1');
                        -> 2022-05-01 01:00:00
                    SELECT TIMESTAMPADD(WEEK, 10, '2022-05-1');
                        -> 2022-07-10
                    SELECT TIMESTAMPADD(YEAR, 1, '2022-05-1');
                        -> 2023-05-01

            DATE_SUB(date, INTERVAL expr unit), тип date
                -- вычитает интервал из даты
                -- ключевое слово INTERVAL объязательно
                Пример:
                    SELECT DATE_SUB('1998-01-02', INTERVAL 31 DAY);
                    -> '1997-12-02'

            DATE_ADD(date, INTERVAL expr unit),  тип date
                -- добавляет к дате интервал
                -- ключевое слово INTERVAL объязательно
                Пример: 
                    SELECT DATE_ADD('2018-05-01',INTERVAL 1 DAY);
                    -> '2018-05-02'

            ADDDATE(expr, days)
                -- добавляет дни к дате
                -- синоним DATE_ADD()
                Прим.:
                    SELECT ADDDATE('2008-01-02', 31);
                        -> '2008-02-02'

            ADDDATE(date, INTERVAL expr unit)
                -- добавляет дни к дате
                -- unit, "Временные интервалы", см. выше или (https://dev.mysql.com/doc/refman/8.0/en/expressions.html#temporal-intervals)
                Прим.:
                    SELECT DATE_ADD('2008-01-02', INTERVAL 31 DAY);
                        -> '2008-02-02'
                    mysql> SELECT ADDDATE('2008-01-02', INTERVAL 31 DAY);
                        -> '2008-02-02'                

            TIMESTAMPDIFF(unit, datetime_expr1, datetime_expr2) типа ЦЕЛО ЧИСЛО
            -- возврат разницы: datetime_expr2 - datetime_expr1 в указанных единицах
            -- unit, единицы измерения результата (возврата функции):
                > YEAR
                > MONTH
                > MINUTE
            -- datetime_expr1-2 типа data или datatime
            Прим.:            
                TIMESTAMPDIFF(YEAR, birthday_at, NOW())
                    > разница в YEAR (годах, то есть)
            TIME_FORMAT(time, format), строковый тип
                -- возвращает строку времени в соотв. с форматом
                -- спецификаторы формата см. ниже DATE_FORMAT() функции
                Пример:
                    SELECT TIME_FORMAT('100:00:00', '%H %k %h %I %l');
                    -> '100 100 04 04 4'
            DATE_FORMAT(date, format) -- тип строковый
                -- обратная функция STR_TO_DATE()
                -- преобразует дату в строку в соответствии с форматом
                -- Спецификаторы формата (https://www.w3schools.com/sql/func_mysql_str_to_date.asp)
                    %D -- день в месяце с английским суффиксом (0th, 1st, 2nd, 3rd, …)
                    %w -- день в неделе цифрами, номера соответсвуют списку (0=Sunday..6=Saturday)
                    %d -- день (00..31) в месяце
                    %e -- день (0..31) в месяце
                    %M -- месяц, имя (January..December)
                    %m -- месяц (00..12)
                    %c -- месяц (0..12)
                    %Y -- год (ГГГГ)
                    %y -- год (ГГ)
                    %p -- AM или PM
                    %r -- время, 12-часовой формат с AM или PM на конце ('hh:mm:ss AM' или 'hh:mm:ssAM')
                    %T -- время, 24-часовой формат (hh:mm:ss)
                    %H -- часы (00..23)
                    %k -- часы (00..23)
                    %h -- часы (00..12)
                    %l -- часы (0..12) -- Внимание: значение 14 (часов) представляются как 2 (часа) -- AM/PM необходимо!!!
                    %I -- часы (0..12)
                    %i -- минуты (00..59)
                    %S -- секунды (00..59)
                    %s -- секунды (0..59)
                    %% -- символ "%"
                Пример:
                    SELECT DATE_FORMAT('2022-05-16 15:20:01', 'На дворе %Y год'); -- извлекаем из строки год...
                    -> 'На дворе 2022 год'
                    SELECT DATE_FORMAT('2022-05-16 15:20:01', '%e.%c.%Y %k:%i');
                    -> '16.5.2022 15:20'

            STR_TO_DATE(str, format)  -- типа datetime
                https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_str-to-date
                -- обратная функция DATE_FORMAT()
                -- любые несовпадения формата приводят к ошибке
                -- спецификаторы формата см. выше DATE_FORMAT()
                Пример с использованием изменённого формата и дополнительного текста:
                    SELECT STR_to_DATE('слово 31.01.2005; 07:15:25', 'слово %d.%m.%Y; %h:%i:%s');
                    -> 2005-01-31 07:15:25
                    SELECT STR_to_DATE('2.01.2005; 07:15:25', '%e.%m.%Y; %T');
                    -> 2005-01-31 07:15:25

            UNIX_TIMESTAMP() -- 4 байта, UNIX-время, количество секунд с 1.1.1970 по 2038 год
                -- может зависить от часового пояса, см. док...
            FROM_UNIXTIME() -- возврат секунд с 1.1.1970 в нормальное представление

            MICROSECOND(expr), целого типа в диапазоне от 0 до 0999999
                -- возвращает микросекунды
                Пример:
                    SELECT MICROSECOND('12:00:00.123456);
                    -> 123456
                    SELECT MICROSECOND('2019-12-31 23:59:59.000010');
                    -> 10
            SECOND() -- Return the second (0-59)
            MINUTE() -- минуты
            HOUR(строка) -- час из строки

            DAY() -- синоним DAYOFMONTH()
            DAYOFMONTH(date), int
                -- число в месяце
                Пример:
                    SELECT DAYOFMONTH('2007-02-03');
                    -> 3
            DAYOFWEEK(date), тип INT
                -- возвращает номер (индекс) дня в неделе
                -- При этом 1--Sunday, 2--Monday, …, = Saturday
                Пример:
                    SELECT DAYOFWEEK('2007-02-03');
                    -> 7
                    *** ПРИМЕЧАНИЕ: 7 -- это суббота!!!
            DAYNAME(date) тип строковый
                -- название дня 
                Пример:
                    SELECT DAYNAME(STR_to_DATE('31.01.2005; 7:15:5', '%d.%m.%Y; %l:%i:%S'));
                    -> Monday
            MONTH(), INT
                -- возвращает месяц с даты
            MONTHNAME() -- название месяца, возвращает строковое значение
            YEAR(date) -- возвращает год
                -- год из даты
                -- date -- строго тип date
                Прим.:
                    SELECT YEAR(NOW());
                    -> 2022
                Пример с неточным заданием типа аргумента (как время, а не как дата):
                    SELECT YEAR('09:01:01');
                    -> 2009
            TO_DAYS(date) -- INT
                -- возвращает номер дня в году
                -- не применяется со значениями меньше 1582 года, то есть до появления григорианского календаря, так как не учитывае дни, которые были потеряны при смене календаря.
                -- см. какой календарь используется (https://dev.mysql.com/doc/refman/5.7/en/mysql-calendar.html)
                Прим.:
                    SELECT TO_DAYS(950501);
                    -> 728779
                    SELECT TO_DAYS('1995-05-01');
                    -> 728779
                    SELECT TO_DAYS('2007-10-07')
                    -> 733321
            TO_SECONDS(expr) тип INT
                -- возвращает количество секунд он начала года
                -- expr типа date или datetime
            SEC_TO_TIME(seconds) тип time
                -- преобразует колиество секунд в сутках во время
                Пример:
                    SELECT SEC_TO_TIME(2378);
                    -> '00:39:38'

            MAKEDATE(year, dayofyear), тип date
                -- Create a date from the year and day of year
                Пример:
                    SELECT MAKEDATE(2022, 32);
                    -> 2022-02-01
                    SELECT MAKEDATE(2022, 365);
                    -> 2022-12-31
            MAKETIME(hour, minute, second), тип time
            -- Create time from hour, minute, second
                Пример:
                    SELECT MAKETIME(13, 54, 59);
                    -> 13:54:59

        Информационные
            VERSION() -- версия SQL
                SELECT VERSION();
               или тоже самое с пустой (несуществующей) таблице
                SELECT VERSION() FROM DUAL;
            DATABASE() -- текущая база данных
                SELECT DATABASE();
                > NULL -- если база не выбрана
            USER() -- текущий пользователь
            
        Счётчик автоинкремента
            LAST_INSERT_ID() 
            -- последнее значение счётчика авто-инкремента...
            -- Удобно использовать в транзакции (или в рамках одной сессии)
                Пример:
                    INSERT INTO catalogs VALUES (NULL, 'Процессоры'); 
                    -- авто-счётчик срабатывает и принимает последнее значение
                    INSERT INTO products (name, description, price, cataloge_id) 
                    VALUES ('Intel Core i3-8100', 'Процессор Intel.', 7890.00, LAST_INSERT_ID()); 
                    -- использование последнего значения для указания последнего нового id из "catalogs".
            AUTO_INCREMENT 
            -- Свойство таблицы
            -- может быть указано после создания таблицы
                Пример:
                    ALTER TABLE users AUTO_INCREMENT=21;
                    CREATE TABLE ...(
                        ...
                    )AUTO_INCREMENT=21;

        Математические
            RAND() -- случайное...
                SELECT * FROM users ORDER BY RAND();
                -- вывод записей в случайном порядке
                SELECT * FROM users ORDER BY RAND() LIMIT 1;
                -- вывод каждый раз отличной записи
            SQRT(n) --  квадратный корень числа n
            POW(n, s) -- возведение числа n в степень s
            ROUND(f) -- округление f до ближайшего целого
            CEILING(f) -- округление f до ближайшего большего целого
            FLOOR(f) -- округление f до ближайшего меньшего целого
            SIGN() -- знак числа
            MOD() -- деление по модулю
            SIN(RADIANS(angle)) -- синус и аргумент в радианах...
            LOG(N) 
                -- логариф натуральный
                -- N < 0 неопределено и возвращает NULL
                -- сумма логарифмов равна логорифму произведения
                   ln(2*3*4*5) = ln(2) + ln(3) + ln(4) + ln(5)
                   Пример:
                    SELECT value
            EXP(N) 
                -- экспанента натуральному логарифму
                -- обратная операция логарифму
                   n = exp(ln(n))
                Пример:
                    SELECT EXP(LOG(10));
                    -> 10
                Пример: произведение двух значений используя сумму:
                    SELECT EXP(LOG(10) + LOG(10))
                    -> 100
                Пример: произведение столбца (с агрегирующей ф. SUM())
                    SELECT EXP(SUM(LOG(value))) FROM tbl WHERE id > 0 ;

        Строковые
            https://dev.mysql.com/doc/refman/8.0/en/string-functions.html
            SUBSTRING('строка', 1, 5) -- выборка из строки символов с 1-ого (начало, всегда с 1-цы) по 5-ый
            SUBSTRING_INDEX(str, delim, count) -- строкового типа, VARCHAR
                -- возвращает подстроку от начала (+/-) до разделителя (delim) по счёту "count".
                Пример:
                    SELECT SUBSTRING_INDEX('www.mysql.com', '.', 2);
                        -> 'www.mysql'
                    SELECT SUBSTRING_INDEX('www.mysql.com', '.', -2);
                        -> 'mysql.com'
                -- чувствительна к регистру delim
            REPLACE() -- Замена вхождений указанной строки

            CONCAT('string-1', 'str-2'), строковое
                -- объединение (сложение) множества подстрок
                Пример:
                    SELECT CONCAT('string-1', '.', 'str-2', '.', 'str-3');
                    -> 'string-1.str-2.str-3'
            CONCAT_WS() -- строковое
                -- объединение строк с разделителем
                Пример:
                    SELECT CONCAT_WS('.', 'string-1', 'str-2', 'str-3');
                    -> 'string-1.str-2.str-3'
                    SELECT CONCAT_WS(',','First name',NULL,'Last Name');
                    -> 'First name,Last Name'
            FIELD(str, 'зн-1', 'зн-2', 'зн-i'...)
                -- обратная ELT()
                -- возвращает номер (i -- индекс) аргумента из списка (1, 2, i), 
                   если он равен str
                -- возвращает позицию (индекс) вхождения значения из списка в str:
                    > i, если str == зн-i
                      где i -- порядковый индекс аргумента в списке после str
                    > 0, если нет совпадений
                    > 0, если NULL.
                Пример. Сортировка выборки в порядке, как задано в IN(...):
                    SELECT id, name FROM users WHERE id IN (2, 3, 1) ORDER BY FIELD(id, 2, 3, 1);
            ELT(N, str1, str2,...)
                -- обратная FIELD()
                -- возвращает строку по номеру N (начальный агргумент)
            FIND_IN_SET(str, list)
                -- возвращает индекс (позицию) подстроки str в длинной строке str_list с разделителями
                -- сама подстрока поиска не должна иметь разделитель.
                Пример:
                    SELECT FIND_IN_SET('b', 'a,b,c,d');
                    -> 2
            INSTR(str, substr)
                -- возвращает положение первого вхождения подстроки (substr) в строке (str)
                -- аналог LOCATE() с двумя аргументами (порядок обратный)
                Пример:
                    SELECT INSTR('foobarbar', 'bar');
                        -> 4
                    SELECT INSTR('xbar', 'foobar');
                        -> 0
            FORMAT(value, D[, locale]) , строковый
                -- форматирует число 
                    > по количеству цифр D после запятой (без округления)
                    > по разделителю разрядов целой части (по параметру locale)
                Пример:
                    SELECT FORMAT(12332.123456, 4);
                    -> '12,332.1235'
                    SELECT FORMAT(12332.1,4);
                    -> '12,332.1000'
                    SELECT FORMAT(12332.2,0);
                    -> '12,332'
                    SELECT FORMAT(12332.2,2,'de_DE');
                    -> '12.332,20'

        Преобразования типов
            BINARY -- приведение строки в двоичной формате
            CAST(expr AS type) [charset_info] -- возвращает значение типа type
                -- преобразование типа expr в тип type
                -- charset_info -- если есть, то тип наборов символов для строки
                -- типы (type):
                    > BINARY[(N)]
                    > CHAR[(N)] -- создаёт VARCHAR-строку
                    > DATE -- тип "дата"
                    > DATETIME -- тип "дата-время"
                    > TIME[(M)] -- создаёт тип time с точночтью M дробных секунд
                    > DECIMAL[(M[,D])] -- создаёт десятичное значение
                    > SIGNED [INTEGER] -- создаёт BIGINT
                    > UNSIGNED [INTEGER] -- создаёт беззнаковое значение BIGINT
                    > JSON -- см. доп. док. (https://dev.mysql.com/doc/refman/5.7/en/json.html#json-comparison)
                    > NCHAR[(N)] -- создаёт строку с национальным набором символов,... см. док. (https://dev.mysql.com/doc/refman/5.7/en/charset-national.html)
            CONVERT(expr, type) -- (соответствует CAST)
            CONVERT(expr USING transcoding_name)
                -- преобразует данные между различными наборами символов.
                Прим.:
                    SELECT CONVERT('abc' USING utf8);
                    -> abc
                    SELECT CONVERT('слово' USING ASCII);
                    -> ?????

        Логические, управление потоком
            https://dev.mysql.com/doc/refman/8.0/en/flow-control-functions.html

            IF(условие, значение-истина, значение-ложь)
                -- функция
                -- выдаёт тип в соответствии с аргументами
                -- логическое выражение не должно быть строковым,
                   так как строка всегда имеет значение TRUE
                   (то есть в кавычки условие брать нельзя!)
                Пример: выдача значения
                    SELECT IF(1 < 2, 'правда', 'ложь') 
                    -> 'правда'
                Пример: изменение порядке сортировки
                    SELECT total FROM order_products ORDER BY IF(total > 0, total, 18446744073709551615);
                    -- сначала все значения в порядке возрастания,
                       а последним нулевое значение!

            CASE 
                -- целая конструкция
                -- множественный выбор
                -- возвращает результат первого успешного сравнения (ИСТИНА)
                -- Внимание: тип возвращаемого результата агрегированный (см. док.!)
                -- Примечание: синтаксис отличается от синтаксиса хранимых процедуры
                Вариант 1: равенство переменной списку значений
                    CASE value|var
                        WHEN compare_value_1 THEN result_1
                        ...
                        WHEN compare_value_2 THEN result_N
                        ELSE result_X
                    END
                Вариант 2: множество условий
                    CASE 
                        WHEN condition_1 THEN result_1
                        ...
                        WHEN condition_1 THEN result_N
                        ELSE result_X
                    END

                Прим.: изменяем значения при выводе (EN на RU)
                    SELECT
                        CASE
                            WHEN firstname = 'Ivan' THEN 'Ваня'
                            WHEN firstname = 'Mikl' THEN 'Миша'
                            ELSE 'неизвестный'
                        END AS ru_name
                    FROM users;
                ...или
                     SELECT
                        CASE (firstname)
                            WHEN 'Ivan' THEN 'Ваня'
                            WHEN 'Mikl' THEN 'Миша'
                            ELSE 'неизвестный'
                        END AS ru_name
                    FROM users;

            IFNULL(expr1, expr2)
                -- возможность исправлять деление на 0.
                -- возращает:
                    > если expr1 является NULL, то возвращает expr2
                    > если expr1 не является NULL, то expr1
                Пример: 
                    SELECT IFNULL(1, 10);
                    -> 1
                    SELECT IFNULL(NULL, 10);
                    -> 10
                    SELECT IFNULL(1/0, 'yes');
                    -> 'yes'

            NULLIF(expr1, expr2) типа первого аргумента или NULL
                -- возвращает:
                    > NULL,  если expr1 = expr2
                    > expr1, если expr1 <> expr2
                Пример:
                    SELECT NULLIF(1,1);
                    -> NULL
                    SELECT NULLIF(1,2);
                    -> 1

            COALESCE(value1, value2, ...); -- агрегированный тип топов аргументов
                -- возвращает первое значение не NULL из списка аргументов
                    Пример:
                        SELECT COALESCE(NULL, 7, NULL, NULL, 1, 2, 3);
                        mysql> 7

        Прочие функции (всмопогательные функции, Miscellaneous Functions)
            https://dev.mysql.com/doc/refman/8.0/en/miscellaneous-functions.html#function_values
            INET_ATON('192.168.1.1') -- преобразование адреса в число
            INET_NTOA( 3232235777) -- обратно...
            UUID() -- универсальный глобальный уникальный идентификатор во времени и пространстве
            VALUES() -- значение по имени поля (колонки)
                https://dev.mysql.com/doc/refman/8.0/en/miscellaneous-functions.html#function_values
                -- определение значения, используемых (попытка использования которых была) 
                   в операторе INSERT
                -- используется для оперирования значением, 
                   строку (запись) с которым почему-то не удалось вставить 
                   при операции INSERT (например, нарушение ограничения ключа)
                Внимание!
                    Не работает: SELECT VALUES(id) FROM users WHERE id = 1;

        Агрегатные (групповые) функции
            см. ниже

    Использование операторов: 
        Вычисляемые поля
            CREATE TABLE _t1 (
                x INT, 
                y INT, 
                s INT AS (x + y) ) ; -- поле не сохраняется на диске и не индексируется
        Вычисляемое с сохранением на диске
            CREATE TABLE _t1 (
                x INT, 
                y INT, 
                s INT AS (x + y) STORED ) ; -- теперь это поле индексируется!

        Условия
            SELECT * FROM catalogs WHERE id_catalog > 2 ;
            SELECT * FROM catalogs WHERE id_catalog > 2 AND id_catalog <= 4 ;
        или тоже самое с конструкцией BETWEEN--AND
            SELECT * FROM catalogs WHERE id_catalog BETWEEN 3 AND 4 ;
        Примеры со временем:
            -- родившиеся в 90-ые годы:
                SELECT * FROM users WHERE birthday_at >= '1990-01-01' AND birthday_at <= '2000-01-01' ;
               или (тоже самое)
                SELECT * FROM users WHERE birthday_at BETWEEN '1990-01-01' AND '2000-01-01' ;
               или
                SELECT * FROM users WHERE birthday_at LIKE '199%' ;
        IN-конструкция со списком (...)
            -- возвращает:
               > TRUE, если значение имеется в списке, 
               > FALSE, если значение отсутствует
               > NULL, если ищется NULL:
                    SELECT NULL IN(2, 3, 5, NULL);
                    > NULL
            -- возвращает NULL, если
                SELECT * FROM catalogs WHERE id_catalog IN (1, 2, 5, NULL) ;
                SELECT * FROM catalogs WHERE id_catalog NOT IN (1, 2, 5, NULL) ;
            -- ВНИМАНИЕ! Отбрасывает повторения.

ГРУППЫ
    а. GROUP BY ... -- собственно, группировка!
    б. теперь сортировка!
    в. LIMIT -- вообще самое последнее, если есть...

    SELECT COUNT(*) AS Total,                     -- количество в группе
           SUBSTRING(birthday_at, 1, 3) AS decade -- десятилетие рождения (декада)
        FROM 
           users
        GROUP BY    -- группировка
           decade   -- по декаде
        ORDER BY
           decade
        LIMIT 2 ; 

    Список значений поля в группе (их список):
        GROUP_CONCAT()
            -- ф-ция, выводящая все значения в группе в строку
            -- максимум 1000 символов (если не указано в параметрах сервера БД иное)
                SET SESSION group_concat_max_len = 4; 
                    > всего 4-е записи в списке на текущую сессию
                    > значение >= 4.
                    > по 2-а (байта) на каждый символ Юникода.
                SET SESSION group_concat_max_len = 1024; 
                    > умолчание
                SET GLOBAL group_concat_max_len = 1024; 
                    > глобально, потребуется рестарт
            Прим. исп.:
                GROUP_CONCAT(users) 
                    -- через запятую и без пробела (по умолчанию)
                GROUP_CONCAT(users SEPARATOR ' ') 
                    -- разделитель -- пробел
                GROUP_CONCAT(users ORDER BY name DESC SEPARATOR '; ') 
                    -- с сортировкой в обратном порядке
                GROUP_CONCAT(DISTINCT users ORDER BY name DESC SEPARATOR '; ') 
                    -- ...только уникальные
        Пример:
            SELECT 
                COUNT(*) AS Total,                     -- количество в группе
                GROUP_CONCAT(name ORDER BY name DESC SEPARATOR ', '),
                SUBSTRING(birthday_at, 1, 3) AS decade -- десятилетие (декада)
            FROM 
                users
            GROUP BY    -- группировка
                decade  -- по декаде
            ORDER BY
                decade
            LIMIT 2 ; 

    HAVING 
        -- условия для подгруппы
        -- можем использовать агрегационные функции 
           (с WHERE это невозможно, так как оно исп. до группы и поэтому не видит результат работы группы)
            Прим.:
                SELECT 
                    COUNT(*) AS total,
                    GROUP_CONCAT(name ORDER BY name DESC SEPARATOR ', '),
                    SUBSTRING(birthday_at, 1, 3) AS decade
                FROM 
                    users
                GROUP BY            -- группировка
                    decade          -- по декаде
                HAVING 
                    total >= 2      -- только группы, в которых более 1-ой позиции
                ORDER BY
                    decade
                LIMIT 2 ; 
        -- можно и без группы, но использовать псевдонимы (с WHERE это не получиться):
            Пример:
                SELECT firstname, lastname, DATE_FORMAT(birthday, '%M') AS b_month FROM users, profiles 
                WHERE users.id=profiles.user_id HAVING b_month IN('may', 'august');

    WITH ROLLUP
        -- дополнение к GROUP BY field_name_grp
        -- возвращает полный список всех field_name_grp для всех групп
        -- работает и для поля count(...) -- возвращает общую сумму всех агрегаций
        -- для всех остальных полей возвращается NULL
        -- сортировка в этом случае не применима
        -- для обработки ситуации с NULL добавлена функция GROUPING(), начиная с MySQL-8.0.1
    
    GROUPING() -- ??????????????????????????????????????
        https://dev.mysql.com/blog-archive/mysql-8-0-grouping-function/
        -- функция используется для различения значения NULL, представляющего набор всех значений 
           в суперагрегированной строке (создаваемой операцией ROLLUP), от NULL в обычной строке.
        -- начиная с MySQL-8.0.1
        -- возвращает 0 (FALS), если значение есть;
        -- возвращает 1 (TRUE), если значение NULL;
        -- может использоваться с функцией IF(...) для изменения значения


Агрегация 
    агрегация данных при помощи функций (для работы с группами, лекция 05) 
    https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html
    -- функции задаются только после SELECT
       > использовать в выражении WHERE нельзя!!!
    -- выполняется при помощи агрегатных функций
    -- возвращают значение для группы
       > если группа не задана, то вся таблица принимается как одна группа
    
    MIN(fild_name)
        -- минимальное зн-ие в группе
        -- фильтр на стоку (запись), 
           > остальные поля в возвращённой записи будут так же актуальны найденному минимальному значению поля fild_name
    MAX(field_name)
        -- максимальное значение поля, 
        -- является фильтром для всей строки, а не только для поля
            > остальные поля в строке (записи) так же будут актуальны, а не случайны
              в отличии от функций sum(), count(), avg()... для которых невозможно найти соотвутствующую запись, с соотвествующим значением искомого поля
        Пример: как вывести максимальное значение?
            Это ошибка:
                SELECT * FROM products WHERE price = MAX(price);
            А это правильно:
                SELECT * FROM products ORDER BY price DESC LIMIT 1;

    COUNT(fild_name)
        -- возвращает количество строк (записей) в группе
        -- не является фильтром записей в выборке, остальные значения полей будут "ненастоящими"
        -- исключает NULL (не считает их)
        -- если "*", то количество включает поля NULL
    COUNT(DISTINCT fild_name)
        -- подсчитываются только уникальные значения поля

    AVG(field_name)
        -- среднее значение в группе
        -- не является фильтром записей в выборке, а вычислением столбца
        -- возвращается значение для столбца, а не найденная запись, поэтому остальные поля будут случайными
           > Так как невозможно найти запись, в которой поле field_name равнялось бы результату работы AVG(field_name)...
        ВНИМАНИЕ: остальные поля в выборке окажуться случайными (или первой записью)

    SUM(field_name)
        -- сумма всех значений столбца
        -- NULL игнорируется
        ВНИМАНИЕ: остальные поля в выборке окажуться случайными (или первой записью)

    ANY_VALUE(field_name)
        -- агрегационная функция-затычка
        -- используется для вывода случайного значения из сгрупированного списка
        Прим.:
            SELECT ANY_VALUE(name)


* * * * * * * * * * * * * * * * * * * * *
МНОГО-ТАБЛИЧНЫЕ ЗАПРОСЫ / СЛОЖНЫЕ ЗАПРОСЫ
    Вложенные запросы
        -- позволяет использовать результат одного запроса в другом,
           подзапроса в самом запросе
        -- вложенный запрос становиться таковым после 
           помещения в круглые скобки
        -- организация:
            SELECT 
                id, 
                (SubQuery)
            FROM 
                (SubQuery) AS pseudo_name  -- здесь псевдоним обязателен!
            WHERE 
                (SubQuery)
            GROUP BY id
            HAVING 
                (SubQuery)
        Пример: найти товар с максимальной ценой (этот запрос не является коррелированным, так как вычисляется один раз)
            SELECT id, name, catalog_id
            FROM products
            WHERE price = (SELECT MAX(price) FROM products);
        -- коррелированный подзапрос: 
            > использует столбец (поле) из внешнего запроса
                Пример: id-поле корреляции
                    SELECT id, (SELECT ... WHERE ..id=id..) AS name FROM order;
            > необходимость вычисления для каждой строки (адресация поля и записи)
            > возвращает одно значение (для одной записи внешнего запроса)
            Пример:
                SELECT 
                    order.id, 
                   (SELECT 
                        product.name 
                    FROM
                        product 
                    WHERE
                        product.id = order.id)
                FROM order;
        -- множественный возврат подзапроса -- необходима обработка списка
            > IN-конструкция: сравнение элементов списка на равенство
              = (равенство) с логикой ИЛИ (если любой элемент равен, возвращается ИСТИНА на весь список)
             
                Пример:
                    SELECT id, name, catalog_id FROM products 
                    WHERE catalog_id IN (1, 2);
                или
                    SELECT id, name, catalog_id FROM products 
                     WHERE catalog_id IN (SELECT id FROM catalogs);
                Внимание!
                    IN(..) отбрасывает повторы

            > ANY(..) -- универсальный: поддерживает все виды сравнений с логикой ИЛИ для всех элементов списка
              <, >, =,.. -- с логикой "ИЛИ"
                Пример: все мат. платы, которые дешевле какой-нибудь позиции из раздела "Процессоры"
                    SELECT id, name, catalog_id 
                      FROM products 
                     WHERE price < ANY (SELECT price FROM products WHERE catalog_id = 1) -- цена процессоров
                       AND catalog_id = 1 -- это системные платы;

            > SOME(..) -- синоним ANY

            > ALL(..) -- универсальный, с логикой "И" (для всех элементов списка)
              <, >, =,.. -- с логикой "И"
                Пример: мат. платы, дороже любого процессора (catalog_id = 1)
                    SELECT id, name, catalog_id 
                      FROM products 
                     WHERE price > ALL (SELECT price FROM products WHERE catalog_id = 1) -- цена процессоров
                       AND catalog_id = 1 -- это системные платы;

            > EXISTS -- если в возвращаемом запросе хотя бы одна строка?
                Пример: 
                -- вывести разделы каталога, для которых есть товар на складе
                    SELECT * FROM catalogs 
                     WHERE EXISTS (SELECT * FROM products WHERE catalog_id = catalogs.id);
                -- вывести разделы каталога, для которых нет ни одной товарной позиции 
                    SELECT * FROM catalogs 
                     WHERE NOT EXISTS (SELECT '1' FROM products WHERE catalog_id = catalogs.id); -- выполняется быстрее

    Строчные вложенные запросы
        -- запросы, возвращающие более одного поля (столбца)
        -- ROW(field1, f2, ...) -- конструктор строки
        Пример: (сравнивается что-то с чем-то)
            SELECT id, name, price, catalog_id 
            FROM products
            WHERE ROW(catalog_id, 5060.00) IN (SELECT id, price FROM catalogs);
    
    Подзапрос в определении источника (FROM)
        -- псевдоним на вложенный запрос обязателен!
            Пример: (здесь можно и обойтись без вложенного запроса...)
                SELECT *
                FROM (SELECT * FROM products WHERE catalog_id=1) AS prod;
        -- вложенный запрос являясь источником передаёт все записи, ключая названия колонок (полей)
           > если необходимо изменить имя колонки, то необходимо так же использовать псевдоним, 
             который и будет передан выше.
            Пример: 
            а) получить минимальные цены в разделах каталога
            б) получить среднюю минимальную цену
                SELECT avg(min_grp_price)
                  FROM (
                       SELECT catalog_id, min(price) AS min_grp_price
                       FROM products p
                       GROUP BY catalog_id
                  ) AS prod ;
            
    Объединения 
        Виды:
        > UNION -- объединение
        > EXEPTION -- разность (множеств), не поддерживается MySQL
        > INTERSCT -- пересечение, не поддерживается MySQL

        UNION [DISTINCT|ALL] -- вертикальное объединение
            -- объединение, вертикальное (операция со множестами)
            -- изменения:
                > колонки не добавляются, 
                > строки прибавляются (вертикальное объединение)
            -- варианты
                > DISTINCT (default) -- без повторений (по умолчанию)
                  >> медленно выполняется, из-за отбрасывания повторений
                > ALL -- включаем все записи (повторения в том числе)
            -- UNION, равноправное объединение двух (нескольких запросов) в один
                > предполагает однотипные данные в объединяемых запросах
                Пример: 
                    SELECT name FROM catalog_1
                      UNION ALL
                    SELECT name FROM catalog_2
                      UNION ALL
                    SELECT name FROM catalog_3 ;
            -- ORDER BY действует на весь результат, а не на отдельную таблицу, 
                        за исключением экранирования под-запроса скобоками
            -- LIMIT n  действует на весь результат, а не на отдельную таблицу, 
                        за исключением экранироания под-запроса скобоками
            -- запрос в скобках становиться вложенным
                Пример экранирования (без отбрасывания дубликатов):
                    (SELECT name FROM catalog_1 ORDER BY name DESK)
                    UNION ALL
                    (SELECT name FROM catalog_2 LIMIT 2);
            -- медленно работают, так как требуют промежуточной таблицы на диске

    JOIN-соединения
        -- похожи на UNION-запросы, но Union -- это веритикальное объединение, а Join -- горизонтальное
        -- позволяют соединять горизонтально (добавлять колонки)
            > не только однотипные результаты,
            > соединяют разноплановые таблицы, 
              задействуя связь "первичный--внешний ключ"
        -- Виды:
            [INNERT] JOIN -- пересечение
            LEFT [OUTER] JOIN  -- все левая таблица и общее пересечение
            RIGHT [OUTER] JOIN -- объединение общего пересечения и всей правой таблицы
            *FULL [OUTER] JOIN -- полное объединение, не поддерживается MySQL
        JOIN (INNER JOIN)
            ---
            Пример

        LEFT [OUTER] JOIN
            ---
            Пример

Транзакции
    https://dev.mysql.com/doc/refman/8.0/en/commit.html
    -- Атомарная (неделимая) группа запросов.
        > не может быть выполена частично
    -- Выполняется всё или ничего (по причине сбоя или логики)
    -- Структура
        START TRANSACTION; -- начало описания транзакции
        select 123 + 1;    -- команды транзакции
        COMMIT;            -- внесение изменений транзакции (фактическое выполнение?)
    -- Отмена транзакции (откат)
        ROLLBACK;          -- отмена транзакции
        ROLLBACK TO SAVEPOINT point_name_1; -- откат до точке сохранения point_name_1
            SAVEPOINT point_name_1; -- объявление точки сохранения
            > если новая точка сохранения имеет такое же имя, то старая удаляется и устанавливается новая.
        > нельзя выполнить откат для:
            CREATE INDEX
            DROP INDEX
            CREATE TABLE
            DROP TABLE
            TRANSCATE TABLE
            ALTER TABLE
            RENAME TABLE
            CREATE DATABASE
            DROP DATABASE
            ALTER DATABASE
        > не рекомендуется, в связи с этим помещать эти команды в транзакцию.
    -- Завершение неявное 
        > операторы, неявно завершающие транзакцию
            ALTER TABLE
            BEGIN
            CREATE INDEX
            CREATE TABLE
            CREATE DATABASE 
            DROP DATABASE 
            DROP INDEX
            DROP TABLE
            LOAD MASTER DATA
            LOCK TABLES 
            RENAME 
            SET AUTOCOMMIT=1
            START TRANSACTION 
            TRUNSCATE TABLE 
    -- Вложенность: 
        > транзакция не может быть вложенной;
        > любой оператор, начинающий транзакцию, приводит к завершению предыдущей.
    -- Автозавершение
        > MySQL работает в режиме автозавершения, то есть любая команда рассматривается
          как транзакция и выполняется немедленно.
          Режим ключается (по умолчанию):
            SET AUTOCOMMIT=1;
        > Отключение автозавершения: для внесения изменений команд необходимо
          выполнить COOMIT или отменить ROLLBACK
            SET AUTOCOMMIT=0;
          восстановление режима автозавершения (занесения)
            SET AUTOCOMMIT=1;
    -- Принципы функционирования
        > требуют много ресурсов
        > ACID (Atomicy, Consistency, Isolation, Durability) -- уловие выполнения транзакций.
            >> Атомарность -- неделимая единицах
            >> Согласованность -- БД переходит из одного непротиворечивого состояния в другое непротиворечивое
            >> Изолированность -- результаты транзакции не видны (обычно) другим транзакциям
        > Уровни изоляции:
            >> READ UNCOMMITDED 
               * грязное чтение, транзакции могут видеть результаты незафиксированных транзакций
            >> READ COMMITDED
               * транзакции увидят только те изменения, которые уже зафиксированы
               * фантомное (невоспроизводимое) чтение: два одинаковых запроса чтения могут привести к разным результатам
            >> REPEATABLE READ (по умолчанию, default)
            >> SERIALIZABLE
               * решаем проблему фантомного чтения
               * заставляет выполнять транзакции в таком порядке, чтобы исключить конфликты
               * блокирует каждую строку, которую транзакция читает
               * возможно множество задержек и конфлктов блокировки
            >> Изменение:
                SET TRANSACTION ISOLATION LEVEL READ COMMITED;

Переменные
    -- временная структура для сохранения данных
        > начинается с символа 
            "@"  -- сеансовая пользовательская и 
            "@@" -- глобальная системеная, 
          за которым следует имя переменной.
        > имя не чувствительно к регистру
    -- объявление и задание значения переменной пользователя:
        > оператором "SET":
            SET @var = 1; -- сеансовая
        > оператором "SELECT" с выводом этого значения:
            SELECT @var := count(*) FROM users; -- получили, сохранили и тут же вывели количество строк в таблице "users"
            SELECT @var := max(price) FROM products; -- получили максимальное значение цены
            SELECT @var := @var + 1 AS nn, name FROM users; -- вывели список пользователей с собственной нумерацией (без id)
        > оператором "SELECT" без вывода:
            SELECT id, name INTO @var_id, @var_name @var_name = name FROM users LIMIT 1;
           или
            SELECT 1, 2 INTO @x, @y;
           или
            SELECT count(*) INTO @x FROM users;

    -- СИСТЕМНЫЕ переменные
        > их имена уже заданы (строго)
        > глобальные (общий размер кэша для сервера, напр.): 
            >> при запуске сервера получают строго значения по умолчанию
                >>> но изменения этих переменных могут быть внесены в конфигурационный файл
                    работающий при для старта
            >> доступны для всех сессий
            >> изменение глобальной переменной видимо всем сессиям, до перезагрузки сервера
            Прим.: изменение глобальной переменной
                SET GLOBAL read_buffer_size = 2097152;
               или
                SET @@global.read_buffer_size = 2097152;
        > сеансовые: 
            >> при запуске сервера получают значения от глобальных системных переменных
        > сеансовые динамические: 
            >> могут быть изменены пользователем на сеанс
            Прим.:
                SET SESSION read_buffer_size = 2097152;
               или 
                SET @@session.read_buffer_size = 2097152;
        > возвращение сеансовой динамической переменной значения от глобальной:
            SET read_buffer_size = DEFAULT;
    -- ИНФО, список системных переменных:
        SHOW VARIABLES;
        Прим: 
            SHOW VARIABLES LIKE AS 'read_%';

Временная таблица:
    -- только на сеанс и изолированно от других сеансов.
    -- "TEMPORARY" -- ключевое слово для создания такой таблицы
            CREATE TEMPORARY TABLE table_temp (id int);
    -- удаление:
            DESCRIBE table_temp;
    -- не принадлежат ни к одной из БД
        > посмотреть можно 
            SHOW TABLES;

Представление ВРЕМЕННОЕ (Динамические запросы)
    -- динамический именнованный запрос
        > только на сеанс
        > PREPARE -- объявляется ключевым словом 
        > ЕХЕСUTE -- запускается 
            Пример:
                PREPARE ver FROM 'SELECT VERSION()';
                EXECUTE ver;
                -> 8.0.23 
        > USING -- параметризация 
            >> только для использования с переменной!
            PREPARE prod 
                FROM 'SELECT pr.id, pr.name AS p_name 
                    FROM shop.products AS pr  
                WHERE pr.id = ?';
            SET @var_prod_id=1;
            EXECUTE prod USING @var_prod_id;
        > DROP PREPARE -- удаление
         Пример:
            DROP PREPARE prod;

Представления
    https://dev.mysql.com/doc/refman/8.0/en/create-view.html 
    -- рассматривается как полноценная таблица, 
       посмотреть можно:
        SHOW TABLES;
    -- определение:
        Пример:
            CREATE OR REPLACE VIEW prod AS 
                SELECT pro.id, pro.name AS 'Name', cat.name AS 'Type' FROM products AS pro JOIN catalogs AS cat ON pro.catalog_id = cat.id;    
    -- ограничения:
        > вертикальные, по количеству выводимых столбцов
        > горизонтальные по количеству выводимых строк (гориз)
        > внутренние, указываются командой в конце описания:
            CREATE OR REPLACE VIEW prod AS 
                SELECT pro.name AS 'Name' FROM products AS pro WHERE pro.id > 1;
                WITH CHECK OPTIONS
    -- INSERT и UPDATE работают с представлением как с обычной таблицей
            CREATE OR REPLACE VIEW prod AS 
                SELECT pro.name AS 'Name' FROM products AS pro;
    -- ALTER VIEW -- редактирование представления:
        ALTER VIEW prod AS ...;
    -- DROP VIEW -- удаление
        DROP VIEW IF EXISTS prod [, v1, v2...];

Процедуры (и функции)
    https://dev.mysql.com/doc/refman/8.0/en/create-procedure.html
    -- Создание, команды:
        CREATE PROCEDURE proc_name ...
        CREATE FUNCTION func_name ...
    -- Особенности:
        > Процедуры вызываются отдельной командой и должны быть вызваны отдельно
            CALL proc_name;
        > Функции возвращают значение и могут быть встраиваемы в запросы
            SELECT func_name(...);
        > Конфликт разделителя комады создания и тела функции (процедуры): 
          * команда создания функции должна завершаться разделителем команд (;),
          * в теле функции так же используются команды и разделитель так же необходим,
          * использование одного разделителя в команде создания и теле функции (пр.) приведёт к ошибке,
            когда команда создания оборвётся раньше, остановившись на разделителе в теле процедуры.
          ВНИМАНИЕ
            Для решения конфликта разделителей команд создания и тела процедур и ф. используется явная замена 
            разделителя для команды создания процедуры. Для этого используется ключевое слово "DELIMITER" (см. ниже)
            Пример:
                DELIMITER //
                CREATE PROCEDURE proc_name()
                    SELECT version(); -- на этот разделитель при выполнении команды создания процедуры MySQL не среагирует
                BEGIN
                END // -- нестандартный разделитель, (зарвешение команды создания)
                DELIMITER ; -- возвращаемся к умолчанию

    -- Процедура
        > тело процедуры ограничивается BEGIN ... END
            Пример:
                CREATE procedure my_proc()
                ... здесь задаётся переменная с глобальной в процедуре видимостью ???
                BEGIN
                    ... переменная среднего уровня
                    BEGIN
                        ... самая "невидимая" переменная
                        SELECT version();
                    END;
                END $$  -- где "$$" замена кавычек
    -- Функция
        > для функции необходим возврат (RETURN)
            Пример:
                CREATE FUNCTION my_f()
                RETURNS TEXT DETERMINISTIC
                BEGIN
                    RETURN VERSION();
                END $$  -- где "$$" замена разделителя команд ";"
        > тип возврата
            >> DETERMINISTIC -- всегда одно значение, MySQL server может его кешировать в рамках запроса
            >> NOT DETERMINISTIC -- возврат различен от вызова к вызову, кэшировать нелья

    -- Направление изменения аргументов, тип изменения аргументов (взаимодействие изменений)
        > видимость аргумента указывается перед его описанием
            CREATE PROCEDURE my_proc (IN value INT)... -- тип видимости аргумента "IN"
        > типы взаимодействия аргумента:
            >> IN
                CREATE FUNCTION my_func (IN var INT)... 
                -> передача данных только внуть функции, изменения наружу невидимы
                -> умолчание и единственный возможный вариант для функций 
            >> OUT
                CREATE PROCEDURE my_proc (OUT proc_var INT)...
                -> инициализация: proc_var присваивается NULL
                   Прим.: передать значение внутрь не получиться!
                -> во внимание принимается только исходящее значение процедуры,
                -> входящее значение игнорируется (видимо, воспринимается как NULL)
                Пример:
                    DELIMITER //
                    CREATE PROCEDURE my_proc (OUT var1 INT, OUT var2 INT)
                    BEGIN
                        SET var1 := var1 + 1; -- Результат: NULL + 1 => NULL, возвращаем NULL
                        SET var2 := 200;      -- Результат: => 200, возвращаем 200
                    END //
                    SET @my_x = 100 //
                    SET @my_y = 5 //
                    CALL my_proc (@my_x, @my_y) //
                    SELECT @my_x, @my_y //
            >> INOUT
                CREATE PROCEDURE (INOUT proc_var INT)...
                -> принимается во внимание как входящее, так и исходящее значения
    -- Переменные внутренние, заданные (только) внутри процедуры (функции)
        DECLARE id, num INT DEFAULT 0; -- задание двух переменных одного типа и инициализация
        Прим.:
            CREATE PROCEDURE my_proc (OUT var1 INT, OUT var2 INT)
            BEGIN
                DECLARE i, k INT DEFAULT 1;
                ... что-то делаем с переменной i
                BEGIN 
                    DECLARE i INT DEFAULT 0; -- верхняя переменная i экранируется этим описанием
                    ... оперируем i уже этого уровня
                    ... оперируем верхней k
                END ;
            END //

    -- Вызов:
        CALL my_proc(); -- вызов процедуры
        SELECT my_func(); -- вызов функции и вывод значения (её результата работы)

    -- Ветвление (внтури процедуры-функ)
        IF (условие) THEN
            ...ОПЕРАТОР ;
        ELSEIF
            ...ОПЕРАТОР ;
        ELSE
            ...ОПЕРАТОР ;
        ENDIF ;

        CASE var
            WHEN 'значени_1' THEN оператор-1;
            WHEN 'значени_2' THEN оператор-2;
            ELSE оператор-x;
        END CASE;

    -- Циклы
        > WHILE -- цикл по условию вначале
            WHILE условие DO           -- условие: если истина, то продолжаем
                ...операторы ;
            END WHILE;

        > REPEATE -- цикл с пост-условием выхода
            REPEATE
                ...оператор;
            UNTIL условие-не-выхода    -- если истина, то прекращаем цикл
            END REPEATE;

        > LOOP -- цикл без условия выхода
            cycle_lable: LOOP
                ...оператор;
                IF условие THEN 
                    LEAVE cycle_lable; -- условие и команда выхода из бесконечного цикла
                END IF;
            END LOOP; 
        > Досрочное завершение 
            >> LEAVE метка -- досрочный выход из цикла по метке (метка обязательна)
                while_lable: WHILE условие DO 
                    ...операторы ;
                    IF условие THEN 
                        LEAVE while_lable -- выход из цикла с меткой "while_lable"
                    END IF;
                END WHILE while_lable; -- завершение описания цикла с меткой "while_lable"
            >> ITERATE метка -- досрочный пропуск итерации цикла с меткой 

    -- Обработка ошибок 
        > описание обработки ошибки может появлятся только в начале функций или процедур
            CREATE PROCEDURE insert_to_catalog (IN id INT, IN name VARCHAR(255))
                BEGIN
                    DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' SET @error = "Ошибка и сообщение..." ;
                    INSERT INTO catalogs VALUES(id, name); -- здесь произошла ошибка и наша переменная @error получила значение
                    IF @error IS NOT NULL THEN
                        SELECT @error; -- выводим сообщение об ошибке
                    END IF;
                END //
        Прим.: при делении на ноль (0) ошибка не генерируется и возвращается NULL

    -- Управление:
        > CALL my_proc(); -- вызовов
        > SHOW PROCEDURE STATUS LIKE 'my_%'; -- посмотреть список хранимых процедур
          SHOW FUNCTION STATUS LIKE 'my_%'; -- посмотреть список хранимых функций
        > DROP PROCEDURE IF EXISTS my_proc; -- удаление
          DROP FUNCTION IF EXISTS my_func;
        > DELIMITER // -- объявление разделителя "//" операторов в скрипте, 
          отличного от используемо в процедуре
            >> Варианты:
                DELIMITER //
                DELIMITER $$
                DELIMITER ; -- default, возврат к разделителю команд по умолчанию
            >> Внимание! 
               Не путать разделитель "//" с ошибочным использованием обратного слеша "\\":
                DELIMITER // -- правильно
                DELIMITER \\ -- ОШИБКА!

Курсоры 
    -- Указатель на запись в таблице
        > объявление курсора
            DECLARE cursor_name CURSOR FOR и далее операция SELECT id, ...;
        > объявление состояния "NOT FOUND" для следующей записи
            DECLARE CONTINUE HANDLER FOR NOT FOUND SET is_end = 1;
        > извлечение данных -- операция с курсором
            FETCH cursor_name INTO id, ...; -- извлечение значений полей из текущей записи
            >> при следующем обращении происходит перемещение к следующей записи
            ...
        > закрытие курсора
            CLOSE cur_usr;
            SET is_end = 0; -- а это на всякий случай сброс флага конца таблицы

    -- Как пробежаться по таблице в цикле? 
       Для этого нужно использовать курсор!
        Пример:
            DROP PROCEDURE IF EXISTS my_proc //
            CREATE PROCEDURE my_proc ()
            BEGIN
                DECLARE id BIGINT default 0;
                DECLARE name VARCHAR(255);
                DECLARE is_end INT DEFAULT 0;
                DECLARE cur_usr CURSOR FOR SELECT u.id FROM sample.users AS u order by u.id ; -- объявляем курсор
                DECLARE CONTINUE HANDLER FOR NOT FOUND SET is_end = 1; -- объявляем обработчик конца ("NOT FOUND")
                -- открываем курсор
                OPEN cur_usr; 
                -- сейчас обойдём всю таблицу
                cycle : LOOP
                    FETCH cur_usr INTO id;  -- читаем данные из первой записи (в начале) или перемещаем на следующую
                    IF is_end = 1 THEN 
                        LEAVE cycle;
                    END IF;
                    SELECT id;
                END LOOP cycle;
                -- закрываем курсор и обнуляем переменную выхода
                CLOSE cur_usr;
                SET is_end = 0;
            END //

            CALL my_proc (@my_y) //

Триггеры
    https://dev.mysql.com/doc/refman/8.0/en/create-trigger.html
    -- процедура (хранимая в БД), привязанная к событию изменения данных в таблице (специальная процедура)
    -- виды событиий, на кот. реагирует триггер:
        > INSERT
        > DELETE
        > UPDATE 
    -- реакция во времени: 
        > BEFORE -- срабатывает до изменения
        > AFTER  -- срабатывает после изменения данных таблицы
    -- создание
        CREATE TRIGGER AFTER INSERT ON users
        FOR EACH ROW -- ??????????????
        BEGIN
            -- ...тело процедуры, со всеми операторами и конструкциями, специфичными для процедуры...
            SELECT COUNT(*) INTO @total_row FROM users; -- кол. строк после INSERT
        END // -- разделитель изменён (командой Delimiter //)
    -- доступ к новым и старым данным:
        OLD -- старые данные
        NEW -- новые данные
            Пример:
                SET NEW.catalog_id = COALESCE(NEW.catalog_id, cat_id); 
                >> если новое значение определено (не NULL), то используем его,
                   а если его не существует (оно NULL), то используем наше cat_id
    -- удаление 
        DROP TRIGGER IF EXISTS tr_name;
    -- список имеющихся в базе:
        SHOW TRIGGERS;
        SHOW TRIGGERS\G;

    -- отмена операции
        > сгенерировать ошибку оператором SIGNAL (или RESIGNAL ????????) переменная_описания_ошибки
            >> номер ошибки 45000 -- необработанное пользовательское исключение
            >> номер ошибки 22012 -- деление на ноль
        Пример: ошибка деления на ноль
            DECLARE division_by_zero CONDITION FOR SQLSTATE '22012';
            DECLARE CONTINUE HANDLER for division_by_zero
                RESIGNAL SET MESSAGE_TEXT = 'Деление на ноль / делитель не должен быть 0';
            -- 
            IF denominator = 0 THEN
                SIGNAL division_by_zero;
            END IF;

       > SQLSTATE 45000 -- ошибка пользовательская, не перехватывается другими...

Администрирование (09 занятие, методичка Администрирование)
    -- Параметры запуска (my.cnf)

    -- Пользователи, права пользователей
        > создание нового и бесправного
            CREATE USER new_user@%;  -- для доступа со всех хостов
        > далее можно авторизоваться:
            $ mysql -u new_user@localhost 
            mysql> SELECT USER(); -- вывести текущего пользователя
        > задание пароля IDENTIFIED...BY
            CREATE USER new_user IDENTIFIED WITH 'sha256_password' BY 'pass';
        > полномочия назначить GRANT
            GRANT ALL ON *.* to 'new_user'@'%' IDENTIFIED WITH 'sha256_password' BY 'pass';
            GRANT SELECT, INSERT, DELETE, UPDATE ON *.* TO new_user; -- перечислены виды операций
            GRANT SELECT (id, name), UPDATE (name) ON shop.catalogs TO new_user ; -- разрешения с указанием таблиц и полей
            GRANT GRANT OPTION ON *.* to new_user; -- полномочия на изменение полномочий (административные), всегда отдельный запрос
        > отобрать REVOKE
            REVOKE ALL ON *.* FROM 'new_user'@'%' ; -- отбираем все (ALL) права на всё (*.*)
            GRANT USAGE, SELECT ON *.* TO new_user ; -- отобрать всё, кроме SELECT
        > переименовать
            RENAME USER usr1 TO usr2 ;
        > удалить
            DROP USER usr1 ;
        > посмотреть полномочия:
            SHOW GRANTS; -- внимание: "GRANTS", а не "GRANT"
        > список пользователей:
            SELECT Host, User FROM mysql.user ;
        

        > технические ограничения (по умолчанию отсутствуют):
            GRANT ALL ON shop.* TO 'new_user'@'localhost' IDENTIFIED WITH 'sha256_password' BY 'pass'
            WITH MAX_CONNECTION_PER_HOUR 10  -- не более 10 подключений в час
                 MAX_QUERIES_PER_HOUR 1000   -- не более 1000 запросов,
                 MAX_UPDATES_PER_HOUR 200    -- из которых только 200 могут быть обнолением (update)
                 MAX_USER_CONNECTIONS 3 ;    -- количество одновременных запросов.
            >> по умолчанию значения == 0, то есть без ограничений.
        
    -- Репликация
        ????????????

    -- Оптимизация (урок 11, видео )
        ?????




* * *  С П Р А В О Ч Н И К  * * *
JSON (формат доступа к даннм этого типа)
    -- См. так же описание типов (выше).
    CREATE TABLE distances (
        id SERIAL PRIMARY KEY,
        a JSON NOT NULL,
        b JSON NOT NULL,
        dist DOUBLE AS (a->>'$.x' - b->>'$.x')
    );
    где
        a = '{"x":7}'
        b = '{"x":5}'
        $ -- обозначение вершины коллекции JSON
        ->> -- доступ в поле к элементу коллекции

Info
    SELECT VERSION();  -- вывести версию SQL-сервера
    SHOW TABLES FROM db_name; -- вывести список таблиц из БД "db_name"
    SELECT mysql.User.User, mysql.User.Host,  FROM mysql.User;
        -- вывести поля User и Host таблицы User из (FROM) базы данных "mysql" и её таблицы "User";
        -- указаны полные, т. е. квалифицированные имена
    SELECT User FROM mysql.User;
        -- тоже, что и выше, но короче...
    SELECT User, Host FROM mysql.User;
        -- вывести поля User и Host из таблицы User базы mysql
    SHOW DATABASES; -- вывести базы данных на сервере.
    SHOW TABLES; -- вывести таблицы в текущей базе.
    SHOW WARNINGS; -- вывод последней ошибки
    SHOW VARIABLES LIKE 'port' -- порт из меременных
    SHOW FULL PROCESSLIST; -- список сессий...
    STATUS -- статус (выбранная база, ...)
    DESCRIBE tablename; -- структура таблицы

?-?-? ОТКРЫТЫЕ ВОПРОСЫ ?-?-?#

SELECT 0  AS SEQUENCE
-- что такое "SEQUENCE"?
    > dbeaver его знает
-- CONNECT BY ???

Источники
https://dev.mysql.com/doc/refman/5.7/en/tutorial.html

https://dev.mysql.com/doc/refman/5.7/en/literals.html

Линн Бейли. Head First. Изучаем SQL. — СПб.: Питер, 2012. — 592 с.

Грофф, Джеймс Р., Вайнберг, Пол Н., Оппель, Эндрю Дж. SQL: полное руководство, 3-е изд. :Пер. с англ. — М.: ООО "И.Д. Вильямс", 2015. — 960 с.

...



2022-05-14. Практическое занятие
2022-06-11. Семинар.



# END