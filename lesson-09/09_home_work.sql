--  GeekBrains, BigData, Oleg Gladkiy (https://geekbrains.ru/users/3837199)
--  Home Work 09
/* A *************************************************************************************
   ТРАНЗАКЦИИ, ПЕРЕМЕННЫЕ, ПРЕДСТАВЛЕНИЯ
   1. В базе данных shop и sample присутствуют одни и те же таблицы, учебной базы данных. Переместите запись id = 1 из таблицы shop.users в таблицу sample.users. Используйте транзакции.
   2. Создайте представление, которое выводит название name товарной позиции из таблицы products и соответствующее название каталога name из таблицы catalogs.
   3.(по желанию) Пусть имеется таблица с календарным полем created_at. В ней размещены разряженые календарные записи за август 2018 года '2018-08-01', '2016-08-04', '2018-08-16' и 2018-08-17. Составьте запрос, который выводит полный список дат за август, выставляя в соседнем поле значение 1, если дата присутствует в исходном таблице и 0, если она отсутствует.
   4.(по желанию) Пусть имеется любая таблица с календарным полем created_at. Создайте запрос, который удаляет устаревшие записи из таблицы, оставляя только 5 самых свежих записей.
****************************************************************************************** */

-- Задание A-1 (ТРАНЗАКЦИИ, ПЕРЕМЕННЫЕ, ПРЕДСТАВЛЕНИЯ)
-- В базе данных shop и sample присутствуют одни и те же таблицы, учебной базы данных. 
-- Переместите запись id = 1 из таблицы shop.users в таблицу sample.users. 
-- Используйте транзакции.

-- Вначале подготовим целевую таблицу: она должна иметь такую-же структуру, как и источник
ALTER TABLE sample.users 
    ADD COLUMN `birthday_at` date DEFAULT NULL COMMENT 'Дата рождения',
    ADD COLUMN `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
    ADD COLUMN `updated_at` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;

-- Начинаем транзакцию
SET AUTOCOMMIT=0; -- чтобы в Dbeaver-е ничего не заносилось и чтобы ошибки не мешали процессу...
START TRANSACTION; -- поехали!

-- Выполняем задание: копируем строку в целевую таблицу, 
-- при этом во-первых она не пустая и, во-вторых, запись с таким ключом (id=1) уже есть
-- так что нам нужно обработать ситуацию нарушения ключа
INSERT INTO sample.users (id, `name`, birthday_at, created_at, updated_at)
    SELECT * FROM ( 
        SELECT id, name, birthday_at, created_at, updated_at FROM shop.users WHERE id = 1
    ) AS shop_new
ON DUPLICATE KEY UPDATE 
    id   =        shop_new.id,
    name =        shop_new.name,
    birthday_at = shop_new.birthday_at,
    created_at  = shop_new.created_at,
    updated_at  = shop_new.updated_at ;

-- ПРИМЕЧАНИЕ: для вставки в нашем случае проще было-бы использовать команду "REPLACE",
-- которая работает как "Update", если запись с таким ключом есть, 
-- и как "Insert", если такой записи нет... Код получается короче: 
-- REPLACE INTO sample.users SELECT * FROM shop.users WHERE id = 1;

-- Завершаем задание: удаляем в источнике (пытаемся)
-- Эта операция (DELETE) не будет выполнена из-за ограничения внешнего ключа таблицы orders, 
-- ссылающуюся на нашу таблицу. Следовательно, вначале нужно переносить записи таблицы orders...
-- Но мы ничего с внешней таблицей делать не будем, значит мы получим ошибку:
DELETE FROM shop.users WHERE id = 1;

-- Из-за ошибки удаления весь код транзакции требуется отменить!
ROLLBACK; -- откат назад до начала транзакции или...
COMMIT;   -- если мы согласны, что запись д.б. не перенесена, а скопирована

-- возвращаемся в исходный режим работы
SET AUTOCOMMIT = 1; -- восстановление режима автозанесения выполнения команд
SELECT * FROM sample.users; -- и посмотрим 
   

-- Задание A-2 (ТРАНЗАКЦИИ, ПЕРЕМЕННЫЕ, ПРЕДСТАВЛЕНИЯ)
-- Создайте представление, которое выводит название name товарной позиции 
-- из таблицы products и соответствующее название каталога name из таблицы catalogs.

USE shop;
CREATE OR REPLACE VIEW prod AS 
    SELECT pro.name AS 'Name', cat.name AS 'Type' FROM shop.products AS pro JOIN shop.catalogs AS cat ON pro.catalog_id = cat.id;

SELECT * FROM prod;


-- Задание A-3. (по желанию) (ТРАНЗАКЦИИ, ПЕРЕМЕННЫЕ, ПРЕДСТАВЛЕНИЯ)
-- Пусть имеется таблица с календарным полем created_at. 
-- В ней размещены разряженые календарные записи за август 2018 года '2018-08-01', 
-- '2016-08-04', '2018-08-16' и 2018-08-17. Составьте запрос, который выводит 
-- полный список дат за август, выставляя в соседнем поле значение 1, 
-- если дата присутствует в исходном таблице и 0, если она отсутствует.

-- потом подумаю...

-- Задание A-4. (по желанию) (ТРАНЗАКЦИИ, ПЕРЕМЕННЫЕ, ПРЕДСТАВЛЕНИЯ)
-- Пусть имеется любая таблица с календарным полем created_at. 
-- Создайте запрос, который удаляет устаревшие записи из таблицы, оставляя только 5 
-- самых свежих записей.

-- потом подумаю...



/* B *************************************************************************************
   АДМИНИСТРИРОВАНИЕ MySQL” (эта тема изучается по вашему желанию)
   1. Создайте двух пользователей которые имеют доступ к базе данных shop. Первому пользователю shop_read должны быть доступны только запросы на чтение данных, второму пользователю shop — любые операции в пределах базы данных shop.
   2. (по желанию) Пусть имеется таблица accounts содержащая три столбца id, name, password, содержащие первичный ключ, имя пользователя и его пароль. Создайте представление username таблицы accounts, предоставляющий доступ к столбца id и name. Создайте пользователя user_read, который бы не имел доступа к таблице accounts, однако, мог бы извлекать записи из представления username.
****************************************************************************************** */

-- Задание B-1 (АДМИНИСТРИРОВАНИЕ MySQL)
-- 1. Создайте двух пользователей которые имеют доступ к базе данных shop. 
-- Первому пользователю shop_read должны быть доступны только запросы на чтение данных, 
-- второму пользователю shop — любые операции в пределах базы данных shop.

DROP USER IF EXISTS shop_read@localhost;
CREATE USER shop_read@localhost IDENTIFIED WITH 'sha256_password' BY '123';
GRANT USAGE, SELECT ON *.* TO shop_read@localhost;
SHOW GRANTS; -- это мы можем посмотреть в консоли под этим пользователем......

DROP USER IF EXISTS 'shop'@'localhost' ;
CREATE USER 'shop'@'localhost' IDENTIFIED WITH 'sha256_password' BY '123';
GRANT ALL ON shop.* TO shop_read@localhost;



/* C *************************************************************************************
   ХРАНИМЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ, ТРИГГЕРЫ
   1. Создайте хранимую функцию hello(), которая будет возвращать приветствие, в зависимости от текущего времени суток. С 6:00 до 12:00 функция должна возвращать фразу "Доброе утро", с 12:00 до 18:00 функция должна возвращать фразу "Добрый день", с 18:00 до 00:00 — "Добрый вечер", с 00:00 до 6:00 — "Доброй ночи".
   2. В таблице products есть два текстовых поля: name с названием товара и description с его описанием. Допустимо присутствие обоих полей или одно из них. Ситуация, когда оба поля принимают неопределенное значение NULL неприемлема. Используя триггеры, добейтесь того, чтобы одно из этих полей или оба поля были заполнены. При попытке присвоить полям NULL-значение необходимо отменить операцию.
   3. (по желанию) Напишите хранимую функцию для вычисления произвольного числа Фибоначчи. Числами Фибоначчи называется последовательность в которой число равно сумме двух предыдущих чисел. Вызов функции FIBONACCI(10) должен возвращать число 55.  
****************************************************************************************** */

-- Задание C-1 (ХРАНИМЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ, ТРИГГЕРЫ)
-- 1. Создайте хранимую функцию hello(), которая будет возвращать приветствие, 
-- в зависимости от текущего времени суток. С 6:00 до 12:00 функция должна возвращать 
-- фразу "Доброе утро", с 12:00 до 18:00 функция должна возвращать фразу "Добрый день", с 18:00 до 00:00 — "Добрый вечер", 
-- с 00:00 до 6:00 — "Доброй ночи".

USE vk;
DELIMITER $$

DROP PROCEDURE IF EXISTS hello $$
CREATE PROCEDURE hello()
BEGIN
    DECLARE current_hour INT DEFAULT 0;
    DECLARE hello_message VARCHAR(255) DEFAULT '';

    SET current_hour = HOUR(NOW());
    
    CASE 
        WHEN(current_hour < 6 
          OR current_hour = 24) THEN 
            SET hello_message = "Доброй ночи.";
        WHEN current_hour < 12 THEN 
            SET hello_message = "Доброе утро!";
        WHEN current_hour < 18 THEN 
            SET hello_message = "Добрый день.";
        WHEN current_hour < 24 THEN 
            SET hello_message = "Добрый вечер.";
        ELSE 
            SET hello_message = "Неизвестная ошибка: час не входит в диапазон, обратитесь к администратору.";
    END CASE;

    SELECT current_hour AS 'Hour', hello_message AS 'Hello';
END $$
DELIMITER ;

CALL hello();


-- Задание C-2 (ХРАНИМЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ, ТРИГГЕРЫ)
-- 2. В таблице products есть два текстовых поля: name с названием товара и 
--    description с его описанием. Допустимо присутствие обоих полей или одно из них. 
--    Ситуация, когда оба поля принимают неопределенное значение NULL неприемлема. 
--    Используя триггеры, добейтесь того, чтобы одно из этих полей или оба поля были 
--    заполнены. При попытке присвоить полям NULL-значение необходимо отменить операцию.

USE shop;

delimiter //

-- Процедура "prod_info_inup_signal" для генерации ошибки
-- используется для оптимизации кода в обоих триггерах (вставки и обновления).

DROP PROCEDURE IF EXISTS prod_info_inup_signal //
CREATE PROCEDURE prod_info_inup_signal()
BEGIN
    DECLARE bad_name_cond CONDITION FOR SQLSTATE '45000';
    DECLARE CONTINUE handler FOR bad_name_cond
        RESIGNAL SET MESSAGE_TEXT = 'Ошибка! Имя или описание должны быть заданы';
    
    SIGNAL bad_name_cond;
END //

-- вставка (триггер)
DROP TRIGGER IF EXISTS prod_info_in //
CREATE TRIGGER prod_info_in BEFORE INSERT ON products
FOR EACH ROW 
BEGIN
    IF (NEW.name IS NULL 
        AND 
        NEW.description IS NULL ) 
    THEN
        CALL prod_info_inup_signal;
    END IF;
END //

-- обновление (триггер)
DROP TRIGGER IF EXISTS prod_info_UP //
CREATE TRIGGER prod_info_UP BEFORE UPDATE ON products
FOR EACH ROW 
BEGIN
    IF (NEW.name IS NULL 
        AND 
        NEW.description IS NULL ) 
    THEN
        CALL prod_info_inup_signal;
    END IF;
END //

delimiter ;

-- ПРОВЕРЯЕМ INSERT:
-- вставляем допустимую запись и у нас должно получиться
INSERT INTO products (name, description) VALUES ('Core to Duo', NULL); 
-- а здесь ситуация, вызывающая ошибку
INSERT INTO products (name, description) VALUES (NULL, NULL); -- ОШИБКА!
-- ПРОВЕРЯЕМ UPDATE:
-- Хотим узнать id последней записи:
SELECT max(id) INTO @max_rec FROM products ;
-- пытаемся выполнить допустимое обновление:
UPDATE products SET name = NULL, description = 'предыдущее поколение процессоров' 
 WHERE id = @max_rec;    -- обновление проходит успешно!
SELECT * FROM products ; -- проверяем
-- а теперь "плохое" обновление должно вызывать ошибку:
UPDATE products SET name = NULL, description = NULL 
 WHERE id = @max_rec; -- НАША ПРАВИЛЬНАЯ ОШИБКА и обновление не проходит!


/*
ОЦЕНКА ПРЕПОДАВАТЕЛЯ: ОТЛИЧНО (Проверено 10.06.2022; 9:41. Сдано мной на проверку: 10.06.2022; 1:40 MSK)

Кирилл Иванов, преподаватель

Правильно, что используете конструкцию "create or replace view..." для пересоздания представления.
Хорошо, что знаете об обеих конструкциях ветвления: IF-THEN-ELSE и CASE-WHEN-THEN.

Моя оценка домашнего задания: большой объём, большая задержка с моей стороны, пришлось пожертвовать дополнительными заданиями.
/*
